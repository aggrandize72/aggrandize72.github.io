<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>长度为 K 子数组中的最大和</title>
      <link href="/2022/11/06/%E7%AE%97%E6%B3%95%E9%A2%98/%E9%95%BF%E5%BA%A6%E4%B8%BA-K-%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
      <url>/2022/11/06/%E7%AE%97%E6%B3%95%E9%A2%98/%E9%95%BF%E5%BA%A6%E4%B8%BA-K-%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。请你从 <code>nums</code> 中满足下述条件的全部子数组中找出最大子数组和：</p><p>子数组的长度是 <code>k</code>，且<br>子数组中的所有元素 各不相同 。<br>返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 <code>0</code> 。</p><p>子数组 是数组中一段连续非空的元素序列。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：nums = [1,5,4,2,9,9,9], k = 3输出：15解释：nums 中长度为 3 的子数组是：- [1,5,4] 满足全部条件，和为 10 。- [5,4,2] 满足全部条件，和为 11 。- [4,2,9] 满足全部条件，和为 15 。- [2,9,9] 不满足全部条件，因为元素 9 出现重复。- [9,9,9] 不满足全部条件，因为元素 9 出现重复。因为 15 是满足全部条件的所有子数组中的最大子数组和，所以返回 15 。</code></pre><p>示例 2：</p><pre><code>输入：nums = [4,4,4], k = 3输出：0解释：nums 中长度为 3 的子数组是：- [4,4,4] 不满足全部条件，因为元素 4 出现重复。因为不存在满足全部条件的子数组，所以返回 0 。`</code></pre><p>提示：</p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="思路：前缀和-滑动窗口-哈希表"><a href="#思路：前缀和-滑动窗口-哈希表" class="headerlink" title="思路：前缀和 + 滑动窗口 + 哈希表"></a>思路：前缀和 + 滑动窗口 + 哈希表</h2><ul><li><p>前缀和 ：用一个保存前缀和数组，然后利用 相减 来求出子数组的和。</p></li><li><p>滑动窗口 ：使用一个长度为k的窗口来模拟一个子数组。<br><img src="/./%E5%9B%BE%E5%BA%93/%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C.png"></p></li><li><p>哈希表 ：使用哈希表来判断窗口里面是否有重复元素。</p></li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>#define max(a,b) ((a) &gt; (b)) ? (a) : (b)long long maximumSubarraySum(int* nums, int numsSize, int k)&#123;    long long max = 0,sum[numsSize + 1];    int hash[100001] = &#123;0&#125;;    int i,count = 0;    sum[0] = 0;    // 求出前缀和数组    for (i = 0; i &lt; numsSize ; i++)        sum[i + 1] = sum [i] + nums[i];    for (i = 0; i &lt; numsSize; i++)&#123;        //count 用来记录子数组中重复元素的个数        if (++ hash[nums[i]] &gt; 1)&#123;            count ++;        &#125;        if (i &gt; k - 1 &amp;&amp; --hash[nums[i - k]] &gt; 0)&#123;            count --;        &#125;        // 若子数组中不存在重复元素，则求出其和，判断大小        if (i &gt; k - 2 &amp;&amp; count == 0)&#123;            max = max(max,sum[i + 1] - sum[i - k + 1]);        &#125;    &#125;    return max;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。数组长度 numsSize </li><li>空间复杂度：<code>O (n)</code>。哈希表以及前缀和数组长度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析布尔表达式</title>
      <link href="/2022/11/05/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E6%9E%90%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/11/05/%E7%AE%97%E6%B3%95%E9%A2%98/%E8%A7%A3%E6%9E%90%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>给你一个以字符串形式表述的 布尔表达式（boolean） <code>expression</code>，返回该式的运算结果。</p><span id="more"></span><p>有效的表达式需遵循以下约定：</p><ul><li><code>&quot;t&quot;</code>，运算结果为 <code>True</code></li><li><code>&quot;f&quot;</code>，运算结果为 <code>False</code></li><li><code>&quot;!(expr)&quot;</code>，运算过程为对内部表达式 <code>expr</code> 进行逻辑 非的运算（NOT）</li><li><code>&quot;&amp;(expr1,expr2,...)&quot;</code>，运算过程为对 <code>2</code> 个或以上内部表达式 <code>expr1, expr2, ...</code> 进行逻辑 与的运算（AND）</li><li><code>&quot;|(expr1,expr2,...)&quot;</code>，运算过程为对 <code>2</code> 个或以上内部表达式 <code>expr1, expr2, ...</code> 进行逻辑 或的运算（OR）</li></ul><p>示例 1：</p><pre><code>输入：expression = &quot;!(f)&quot;输出：true</code></pre><p>示例 2：</p><pre><code>输入：expression = &quot;|(f,t)&quot;输出：true</code></pre><p>示例 3：</p><pre><code>输入：expression = &quot;&amp;(t,f)&quot;输出：false</code></pre><p>示例 4：</p><pre><code>输入：expression = &quot;|(&amp;(t,f,t),!(t))&quot;输出：false</code></pre><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>利用栈，将每一个左右括号进行匹配，即可求出答案。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>bool parseBoolExpr(char * expression)&#123;    int len = strlen(expression);    char stack[len];    int top = 0;    for (int i = 0;i &lt; len;i++)&#123;        if (expression[i] == &#39;,&#39;)            continue;        if (expression[i] != &#39;)&#39;)            stack[top++] = expression[i];        else&#123;            int f = 0, t = 0;            while (stack[top - 1] != &#39;(&#39;)&#123;                char c = stack[--top];                if (c == &#39;f&#39;)                    f++;                if (c == &#39;t&#39;)                    t++;            &#125;            char val = stack[top - 2];            top -= 2;            switch (val)&#123;                case &#39;!&#39;:&#123;                    stack[top++] = t == 1 ? &#39;f&#39; : &#39;t&#39;;                    break;                &#125;                case &#39;&amp;&#39;:&#123;                    stack[top++] = f &gt; 0 ? &#39;f&#39; : &#39;t&#39;;                    break;                &#125;                case &#39;|&#39;:&#123;                    stack[top++] = t &gt; 0 ? &#39;t&#39; : &#39;f&#39;;                    break;                &#125;                default:                    break;            &#125;          &#125;    &#125;    return stack[0] == &#39;t&#39;;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。表达式的长度。</li><li>空间复杂度：<code>O (n)</code>。栈的容量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根据身高重建队列</title>
      <link href="/2022/11/02/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/"/>
      <url>/2022/11/02/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 正好 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p><p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]解释：</code></pre><p>示例 2：</p><pre><code>输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</code></pre><h2 id="思路：先排好高的人再排低的"><a href="#思路：先排好高的人再排低的" class="headerlink" title="思路：先排好高的人再排低的"></a>思路：先排好高的人再排低的</h2><p>这个思路意思大概就是，我人高，看不见比我矮的人，比我矮的都可以无视。</p><p>所以首先，把数组 <code>people</code> 按身高进行排序，（[7,0] 得排在 [7,1] 前面）。</p><p>然后就只需要看 <code>ki</code> 的值，它的值为多少就排在第几。</p><p>比如 <code>[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</code> 这五的人需要排队。</p><p>我们先按高矮将他们排一次。</p><p>排成了这样 <code>[[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]</code></p><p>然后只需要看 <code>ki</code> 值，他的值为多少，我们就插入至哪个位置。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>int cmp(const void* _a, const void* _b) &#123;    int *a = *(int**)_a, *b = *(int**)_b;    return a[0] == b[0] ? a[1] - b[1] : b[0] - a[0];&#125;int** reconstructQueue(int** people, int peopleSize, int* peopleColSize, int* returnSize, int** returnColumnSizes) &#123;    //将数组 people 按高矮进行排序。    qsort(people, peopleSize, sizeof(int*), cmp);    int** ans = malloc(sizeof(int*) * peopleSize);    *returnSize = 0;    *returnColumnSizes = malloc(sizeof(int) * peopleSize);    for (int i = 0; i &lt; peopleSize; i++) &#123;        (*returnColumnSizes)[i] = 2;    &#125;    //现在开始插队    for (int i = 0; i &lt; peopleSize; ++i) &#123;        int* person = people[i];        (*returnSize)++;        // 将 ki 位置腾出来，让该学生插入。        for (int j = (*returnSize) - 1; j &gt; person[1]; j--) &#123;            ans[j] = ans[j - 1];        &#125;        int* temp = malloc(sizeof(int) * 2);        // temp 用来保存 该学生的数据。        temp[0] = person[0], temp[1] = person[1];        // 插入队伍        ans[person[1]] = temp;    &#125;    return ans;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n^2)</code>。</li><li>空间复杂度：<code>O(n)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分割回文串</title>
      <link href="/2022/11/01/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>/2022/11/01/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 回文串 。返回 <code>s</code> 所有可能的分割方案。</p><p>回文串 是正着读和反着读都一样的字符串。</p><span id="more"></span><p> </p><p>示例 1：</p><pre><code>输入：s = &quot;aab&quot;输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;a&quot;输出：[[&quot;a&quot;]]</code></pre><h2 id="思路一：回溯-动态规划预处理"><a href="#思路一：回溯-动态规划预处理" class="headerlink" title="思路一：回溯 + 动态规划预处理"></a>思路一：回溯 + 动态规划预处理</h2><ul><li>动态规划：</li></ul><p>使用二维数组 <code>f[i][j]</code> 表示 从字符串 <code>s</code> 中的第 <code>i</code> 到第 <code>j</code> 的位置是否 为回文串，若是，则为 <code>1</code> ，不是则为 <code>0</code> 。</p><ul><li>回溯：</li></ul><p>现在已经保存了一个二维数组，我们可以从 <code>i</code> 开始，从小到大依次枚举 <code>j</code>。对于当前枚举的 <code>j</code> 值，我们查看 <code>f[i][j]</code> 的值 <code>s[i..j]</code> 是否为回文串：如果 <code>s[i..j]</code> 是回文串，那么就将其加入答案数组 <code>ans</code> 中，并以 <code>j+1</code> 作为新的 <code>i</code> 进行下一层搜索，并在未来的回溯时将 <code>s[i..j]</code> 从 <code>ans</code> 中移除。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>//深度优先搜索void DFS(char* s, int n, int i, int** f, char*** ret, int* retSize, int* retColSize, char** ans, int* ansSize) &#123;    //若将整个字符串分段存放至 ans 中，则输入进 ret 中。    if (i == n) &#123;        char** tmp = malloc(sizeof(char*) * (*ansSize));        for (int j = 0; j &lt; (*ansSize); j++) &#123;            int ansColSize = strlen(ans[j]);            tmp[j] = malloc(sizeof(char) * (ansColSize + 1));            strcpy(tmp[j], ans[j]);        &#125;        ret[*retSize] = tmp;        retColSize[(*retSize)++] = *ansSize;        return;    &#125;    //深度优先    for (int j = i; j &lt; n; ++j) &#123;        if (f[i][j]) &#123;            char* sub = malloc(sizeof(char) * (j - i + 2));            for (int k = i; k &lt;= j; k++) &#123;                sub[k - i] = s[k];            &#125;            sub[j - i + 1] = &#39;\0&#39;;            ans[(*ansSize)++] = sub;            DFS(s, n, j + 1, f, ret, retSize, retColSize, ans, ansSize);            --(*ansSize);        &#125;    &#125;&#125;// ret[i][j][k]// returnSize 即是 i 的最大值// returnColumnSizes[i] 即是每个 i 对应的 j 的最大值char*** partition(char* s, int* returnSize, int** returnColumnSizes) &#123;    int n = strlen(s);    int retMaxLen = n * (1 &lt;&lt; n);    char*** ret = malloc(sizeof(char**) * retMaxLen);    *returnSize = 0;    *returnColumnSizes = malloc(sizeof(int) * retMaxLen);    // 创建保存 回文串 位置的数组。    int* f[n];    for (int i = 0; i &lt; n; i++) &#123;        f[i] = malloc(sizeof(int) * n);        for (int j = 0; j &lt; n; j++) &#123;            f[i][j] = 1;        &#125;    &#125;    for (int i = n - 1; i &gt;= 0; --i) &#123;        for (int j = i + 1; j &lt; n; ++j) &#123;            f[i][j] = (s[i] == s[j]) &amp;&amp; f[i + 1][j - 1];        &#125;    &#125;    char* ans[n];    int ansSize = 0;    dfs(s, n, 0, f, ret, returnSize, *returnColumnSizes, ans, &amp;ansSize);    return ret;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n* 2^n)</code>。</li><li>空间复杂度：<code>O (n^2)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2022/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/"/>
      <url>/2022/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2022/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/"/>
      <url>/2022/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>神奇字符串</title>
      <link href="/2022/10/31/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%A5%9E%E5%A5%87%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/10/31/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%A5%9E%E5%A5%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>神奇字符串 <code>s</code> 仅由 <code>&#39;1&#39;</code> 和 <code>&#39;2&#39;</code> 组成，并需要遵守下面的规则：</p><p>神奇字符串 <code>s</code> 的神奇之处在于，串联字符串中 <code>&#39;1&#39;</code> 和 <code>&#39;2&#39;</code> 的连续出现次数可以生成该字符串。<br><code>s</code> 的前几个元素是 <code>s = &quot;1221121221221121122……&quot;</code> 。如果将 <code>s</code> 中连续的若干 <code>1</code> 和 <code>2</code> 进行分组，可以得到 <code>&quot;1 22 11 2 1 22 1 22 11 2 11 22 ......&quot;</code> 。每组中 <code>1</code> 或者 <code>2</code> 的出现次数分别是 <code>&quot;1 2 2 1 1 2 1 2 2 1 2 2 ......&quot;</code> 。上面的出现次数正是 <code>s</code> 自身。</p><p>给你一个整数 <code>n</code> ，返回在神奇字符串 <code>s</code> 的前 <code>n</code> 个数字中 <code>1</code> 的数目。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre><code>输入：n = 6输出：3解释：神奇字符串 s 的前 6 个元素是 “122112”，它包含三个 1，因此返回 3 。 </code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 1输出：1</code></pre><h2 id="思路：双指针"><a href="#思路：双指针" class="headerlink" title="思路：双指针"></a>思路：双指针</h2><p>利用双指针，第一个指针用来遍历整个字符串。<br>第二个指针用来决定第一个指针所指位置的值。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>int magicalString(int n)&#123;    char *s = (char*)malloc (n+1);    int num = 0,flag = 1,changFlag = 1;    //双指针分别是 i 和 pos 。    for (int i = 0,pos = 0;i &lt; n;i++)&#123;        s[i] = flag + &#39;0&#39;;        num += s[i] - &#39;0&#39;;        // changFlag 用来判断 flag 是否需要变值        if (changFlag != s[pos] - &#39;0&#39;)&#123;            changFlag ++;        &#125;else &#123;            changFlag = 1;            pos++;            // 转变数字             flag ^= 3;        &#125;    &#125;    return 2 * n - num;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。遍历了整个字符串一遍。</li><li>空间复杂度：<code>O (n)</code>。需要构造长度为 n 的字符串。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字母大小写全排列</title>
      <link href="/2022/10/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2022/10/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串 <code>s</code> ，通过将字符串 <code>s</code> 中的每个字母转变大小写，我们可以获得一个新的字符串。</p><p>返回所有可能得到的字符串集合 。以<strong>任意顺序</strong>返回输出。</p><span id="more"></span><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;a1b2&quot;输出：[&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: s = &quot;3z4&quot;输出: [&quot;3z4&quot;,&quot;3Z4&quot;]</code></pre><p><strong>提示：</strong></p><ul><li><code>s</code> 的长度不超过12.</li><li><code>s</code> 由小写英文字母、大写英文字母和数字组成</li></ul><h2 id="思路一：广度优先搜索"><a href="#思路一：广度优先搜索" class="headerlink" title="思路一：广度优先搜索"></a>思路一：广度优先搜索</h2><p>从左往右遍历字符串，当我们遍历下一个字符 <code>c</code> 时：</p><ul><li>如果 <code>c</code> 为一个数字，则队列中所有的序列的末尾均加上 <code>c</code> ，将修改后的序列再次进入到队列中；</li><li>如果 <code>c</code> 为一个字母，此时我们在上述序列的末尾依次分别加上 <code>c</code> 的小写形式 <code>lowercase(c)</code> 和 <code>c</code> 的大写形式 <code>uppercase(c)</code> 后，再次将上述数列放入队列；</li><li>如果队列中当前序列的长度等于 <code>s</code> 的长度，则表示当前序列已经搜索完成，该序列为全排列中的一个合法序列；</li></ul><p>由于每个字符的大小写形式刚好差了 32，因此在大小写转换时可以用 C⊕32 来进行转换。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>//链表队列的结构体typedef struct node&#123;    char str[16];    struct node *next;&#125;Node;//建立一个 节点Node * creatNode(char * str)&#123;    Node * node = (Node*)malloc (sizeof(Node));    memset(node,0,16);    strcpy(node-&gt;str,str);    node-&gt;next = NULL;    return node;&#125;//返回函数char ** letterCasePermutation(char * s, int* returnSize)&#123;    int n = strlen (s);    char **ans = (char**)malloc(sizeof(char*)* (1 &lt;&lt; n));// &lt;&lt; 是位运算符，左移    int pos = 0;    //现在创建个链表队列    Node *head = NULL,*tail = NULL;    head = tail = creatNode(&quot;&quot;);    while(head)&#123;        char *curr = head-&gt;str;        int len = strlen(curr);        if(len == n)&#123;            //若已经遍历完成，则将队列头字符串加入至ans中            ans[pos] = (char*)malloc(sizeof(char)*16);            strcpy(ans[pos++],head);            head = head-&gt;next;        &#125;else&#123;            //若s[len]是字母则向队列中加入            if(isalpha(s[len]))&#123;                tail-&gt;next = creatNode(curr);                tail = tail-&gt;next;                tail-&gt;str[len] = s[len] ^ 32;// ^ 是位运算符，异或            &#125;            curr[len] = s[len];        &#125;    &#125;    *returnSize = pos;    return ans;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li><p>时间复杂度：<code>O (n * 2^n)</code>。 其中 n 表示字符串的长度。全排列的数目最多为 2^n 个，每次生成一个新的序列的时间为 O(n)，因此时间复杂度为 O(n * 2^n) 。</p></li><li><p>空间复杂度：<code>O (n * 2^n)</code>。其中 n 表示字符串的长度。队列中的元素数目最多为 2^n 个，每个序列需要的空间为为 O(n)，因此空间复杂度为 O(n * 2^n) 。</p></li></ul><h2 id="思路二：回溯"><a href="#思路二：回溯" class="headerlink" title="思路二：回溯"></a>思路二：回溯</h2><p>同样的思路我们还可以采用回溯的思想，从左往右依次遍历字符，当在进行搜索时，搜索到字符串 s 的第 i 个字符时：</p><ul><li>如果 c 为一个数字，则我们继续检测下一个字符；</li><li>如果 c 为一个字母，我们将字符中的第 i 个字符 c 改变大小写形式后，往后继续搜索，完成改写形式的子状态搜索后，我们将 c 进行恢复，继续往后搜索；</li><li>如果当前完成字符串搜索后，则表示当前的子状态已经搜索完成，该序列为全排列中的一个；</li></ul><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><pre><code>void dfs(char *s, int pos, char **res,int* returnSize) &#123;    //当 c 为数字时跳过。    while (isdigit(s[pos]) &amp;&amp; s[pos++] != &#39;\0&#39;);    //当遍历完字符串时。将字符串 s 放入 res 中。    if (s[pos] == &#39;\0&#39;) &#123;        res[*returnSize] = (char *)malloc(sizeof(char) * (strlen(s) + 1));        strcpy(res[*returnSize], s);        (*returnSize)++;        return;    &#125;    //若这个位置是字母，则将字母的大小写分别写进2个函数。    //开始递归。    s[pos] ^= 32;    dfs(s, pos + 1, res, returnSize);    s[pos] ^= 32;    dfs(s, pos + 1, res, returnSize);&#125;//返回函数char ** letterCasePermutation(char * s, int* returnSize) &#123;    int n = strlen(s);    *returnSize = 0;    char **ans = (char **)malloc(sizeof(char *) * (1 &lt;&lt; n));    dfs(s, 0, ans, returnSize);    return ans;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li><p>时间复杂度：<code>O (n * 2^n)</code>。 其中 n 表示字符串的长度。递归深度最多为 n，所有可能的递归子状态最多为 2^n 个，每次个子状态的搜索时间为 O(n)，因此时间复杂度为 O(n * 2^n) 。</p></li><li><p>空间复杂度：<code>O (1)</code>。除返回值以外不需要额外的空间 。</p></li></ul><h2 id="思路三：-二进制位图"><a href="#思路三：-二进制位图" class="headerlink" title="思路三： 二进制位图"></a>思路三： 二进制位图</h2><p>假设字符串 s 有 m 个字母，那么全排列就有 2^m 个字符串序列，且可以用位掩码 bits 唯一地表示一个字符串。</p><ul><li>bits 的第 i 位为 0 表示字符串 s 中从左往右第 i 个字母为小写形式</li><li>bits 的第 i 位为 1 表示字符串 s 中从左往右第 i 个字母为大写形式</li></ul><p>我们采用的位掩码只计算字符串 s 中的字母，对于数字则直接跳过，通过位图计算从而构造正确的全排列。我们依次检测字符串第 i 个字符串 c：</p><ul><li><p>如果字符串 c 为数字，则我们直接在当前的序列中添加字符 c；</p></li><li><p>如果字符串 c 为字母，且 c 为字符串中的第 k 个字母，如果掩码 bits 中的第 k 位为 0，则添加字符串 c 的小写形式；如果掩码 bits 中的第 k 位为 1，则添加字符串 c 的大写形式；</p></li></ul><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><pre><code>char ** letterCasePermutation(char * s, int* returnSize)&#123;    int n = strlen(s);    int m = 0;    for (int i = 0; i &lt; n; i++) &#123;        if (isalpha(s[i])) &#123;            m++;        &#125;    &#125;    char **ans = (char **)malloc(sizeof(char *) * (1 &lt;&lt; m));    for (int mask = 0; mask &lt; (1 &lt;&lt; m); mask++) &#123;        //mask即是 二进制位图        //现在是将 2^m 个字符串依次按照位图信息存入ans中。        ans[mask] = (char *)malloc(sizeof(char) * (n + 1));        ans[mask][n] = &#39;\0&#39;;        for (int j = 0, k = 0; j &lt; n; j++) &#123;             if (isalpha(s[j]) &amp;&amp; (mask &amp; (1 &lt;&lt; k++))) &#123;                //若是字母，且位图 mask 中的第 j 位为 1 则添加大字母。                ans[mask][j] = toupper(s[j]);            &#125; else &#123;                //第 j 位是数字则直接添加 c                 ans[mask][j] = tolower(s[j]);            &#125;        &#125;    &#125;    *returnSize = (1 &lt;&lt; m);    return ans;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li><p>时间复杂度：<code>O (n * 2^n)</code>。 其中 n 表示字符串的长度。最多有 2^n 个序列，每次生成一个新的序列的时间为 O(n)，因此时间复杂度为 O(n * 2^n) 。</p></li><li><p>空间复杂度：<code>O (1)</code>。除返回值以外不需要额外的空间 。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 广度优先搜索 </tag>
            
            <tag> 回溯 </tag>
            
            <tag> 位图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="/2022/10/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/10/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：head = [1,2,3,4,5]输出：[5,4,3,2,1]</code></pre><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>新建一个链表头。让目标链表依次指向链表头。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>Definition for singly-linked list.struct ListNode &#123;    int val;    struct ListNode *next;&#125;;struct ListNode* reverseList(struct ListNode* head)&#123;    //新链表头    struct ListNode *newListHead = NULL;    struct ListNode *tempNode = NULL;    while(head)&#123;        //储存当前链表的下一个节点的地址        tempNode = head-&gt;next;        //当前链表的当前节点指向新链表头        head-&gt;next = newListHead;        //因为新链表头有变化，更新 新链表头。        newListHead = head;        //接着处理当前链表的下一个节点        head = tempNode;    &#125;    return newListHead;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。遍历整个链表。</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2022/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>链表（List）是是一种线性表数据结构。它用不连续的内存空间，来存储一组具有相同类型的数据。</p><span id="more"></span><h2 id="链表的优缺点："><a href="#链表的优缺点：" class="headerlink" title="链表的优缺点："></a>链表的优缺点：</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>是一种动态数据结构。</li><li>易于插入和删除。</li><li>内存利用率高。</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>储存密度低，比较浪费内存，因为储存元素时，需要额外存储指针。</li><li>不支持随机访问。</li><li>查找元素效率低。</li></ul><h2 id="理解指针或引用的含义"><a href="#理解指针或引用的含义" class="headerlink" title="理解指针或引用的含义"></a>理解指针或引用的含义</h2><p>要学好链表，首先得学好指针。</p><p>指针的理解：</p><p>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</p><p>简单的来说就是：</p><pre><code>int *p = data;//则这下面两个都是 true *p == data;p == &amp;data;</code></pre><h2 id="链表的种类："><a href="#链表的种类：" class="headerlink" title="链表的种类："></a>链表的种类：</h2><ul><li><p>单向链表</p><p>  结构代码：</p></li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct <span class="keyword">node</span><span class="title">&#123;</span></span><br><span class="line"><span class="title">    int</span> value;</span><br><span class="line">    struct <span class="keyword">node</span> <span class="title">*next</span>;</span><br><span class="line">&#125;singlyLinkList;</span><br></pre></td></tr></table></figure><ul><li><p>双向链表</p><p>  结构代码：</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct <span class="built_in">double</span>Node&#123;</span><br><span class="line">    <span class="built_in">int</span> value;</span><br><span class="line">    struct <span class="built_in">double</span>Node *prior;</span><br><span class="line">    struct <span class="built_in">double</span>Node *next;</span><br><span class="line">&#125;<span class="built_in">double</span>LinkList;</span><br></pre></td></tr></table></figure><ul><li>循环链表</li></ul><p>循环链表的结构代码和前面两个一样，就是把尾节点和首节点连起来了。</p><h2 id="数据的查找、插入和删除"><a href="#数据的查找、插入和删除" class="headerlink" title="数据的查找、插入和删除"></a>数据的查找、插入和删除</h2><h3 id="查找："><a href="#查找：" class="headerlink" title="查找："></a>查找：</h3><p>查找只能遍历整个链表。时间复杂度 O(n)。</p><h3 id="插入："><a href="#插入：" class="headerlink" title="插入："></a>插入：</h3><p>插入节点为 p2 ，将插入在 p1 之后。</p><p>代码实现：</p><pre><code>p2-&gt;next = p1-&gt;next;p1-&gt;next = p2;</code></pre><p>时间复杂度为 O(1) 。</p><h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><p>只需将该节点的上一个节点的 next 值指向这个节点的 next 即完成节点的删除。</p><p>代码实现：</p><pre><code>p-&gt;next = p-&gt;next-&gt;next;</code></pre><p>这样就将p的下一个节点删除了（还要将删除的空间给 free 掉）。</p><p>时间复杂度为 O(1) 。</p><h2 id="边界问题（设置哨兵）"><a href="#边界问题（设置哨兵）" class="headerlink" title="边界问题（设置哨兵）"></a>边界问题（设置哨兵）</h2><p>在插入删除头节点这个边界问题时，和其他节点时的代码不一样，那就需要使用不同的代码进行描述。</p><p>为了解决这种问题，我们可以在单链表的第一个节点之前设置个节点（一般称为哨兵节点），不保存数据只指向链表的第一个节点，这样，所有的操作都可以用相同的代码进行实现。</p><hr><p><a href="http://caoxing.run/tags/%E9%93%BE%E8%A1%A8/">关于链表的一些练习</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2022/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"/>
      <url>/2022/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p><span id="more"></span><h2 id="数组的优缺点："><a href="#数组的优缺点：" class="headerlink" title="数组的优缺点："></a>数组的优缺点：</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>按照索引查询元素速度快</li><li>能存储大量数据</li><li>按照索引遍历数组方便</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>根据内容查找元素速度慢</li><li>数组的大小一经确定不能改变。</li><li>数组只能存储一种类型的数据</li><li>增加、删除元素效率慢</li><li>未封装任何方法，所有操作都需要用户自己定义。</li></ul><h2 id="数组如何实现随机访问？"><a href="#数组如何实现随机访问？" class="headerlink" title="数组如何实现随机访问？"></a>数组如何实现随机访问？</h2><p>主要取决于数组的特性：</p><ul><li>是一种线性表（Linear List）。</li><li>连续的内存空间和相同类型的数据。</li></ul><p>计算机需要访问某个元素时，需要通过下面的寻址公式，来计算出元素的内存地址以达到随机访问的目的：</p><pre><code>a[i]_address  = base_address + i * data_type_size</code></pre><h2 id="数组下标为什么不从-1-开始？"><a href="#数组下标为什么不从-1-开始？" class="headerlink" title="数组下标为什么不从 1 开始？"></a>数组下标为什么不从 1 开始？</h2><p>从数组的内存模型上看，数组”下标”最确切的定义是”偏移（offset）”。一般编程时，都是以 a 来表示数组的首地址，a[0] 就是偏移为 0 个位置。a[k] 则表示偏移 k 个 type_size 的位置。</p><p>所以计算 a[k] 的内存地址就要用到这个公式：</p><pre><code>a[k]_address  = base_address + k * data_type_size</code></pre><p>若以 1 为下标开始的话 a[k] 内存地址就变为：</p><pre><code>a[k]_address  = base_address + (k - 1) * data_type_size</code></pre><p>这样每次访问数组元素时都多了一次减法，对于 CPU 来说，就是相当于多了一次减法指令。数组又作为一个非常基础的数据结构，通过下标随机访问数组元素又是非常常见的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次指令操作，数组就选择以 0 开始编号，而不是 1 开始。</p><p>当然这也不是很绝对，也是有很多语言并不是从 0 开始计数的，例如 Matlab 。甚至还有一些语言支持负数下标，例如 Python 。 </p><h2 id="数组的查找、插入和删除。"><a href="#数组的查找、插入和删除。" class="headerlink" title="数组的查找、插入和删除。"></a>数组的查找、插入和删除。</h2><h3 id="查找："><a href="#查找：" class="headerlink" title="查找："></a>查找：</h3><p>一般 数组的查找的时间复杂度是 O(n) ；</p><p>但对于已经排好序的数组来说，可以利用二分查找，时间复杂度是 O(logn);</p><p>数组是你说根据下标随机访问的时间复杂度为 O(1)。</p><h3 id="插入和删除："><a href="#插入和删除：" class="headerlink" title="插入和删除："></a>插入和删除：</h3><p>因为数组的特性，所以我们插入和删除时也要保证内存数据的连续性。</p><p>这样我们插入和删除两个操作就变得比较的低效。</p><ul><li>最好情况：插入和删除时间复杂度 O(1);（操作数在末尾）</li><li>最坏情况：插入和删除时间复杂度 O(n);（操作数在头部）</li><li>平均情况：插入和删除时间复杂度 O(n)；因为删除每个位置的元素的概率相同，故需要操作次数为（1+2+3+…+n）&#x2F; n &#x3D; (n + 1) &#x2F; 2 ；所以时间复杂度还是 O(n) 。</li></ul><h2 id="警惕数组访问越界的问题。"><a href="#警惕数组访问越界的问题。" class="headerlink" title="警惕数组访问越界的问题。"></a>警惕数组访问越界的问题。</h2><p>数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。</p><p>因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。这种情况下，一般都会出现莫名其妙的逻辑错误。</p><p>而且，很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。但并非所有的语言都像 C 一样，把数组越界检查的工作丢给程序员来做，像 Java 和 Python 本身就会做越界检查，若越界java就会抛出 java.lang.ArrayIndexOutOfBoundsExcept。</p><hr><p><a href="http://caoxing.run/tags/%E6%95%B0%E7%BB%84/">关于数组的一些练习</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>下一个更大元素 I</title>
      <link href="/2022/10/28/%E7%AE%97%E6%B3%95%E9%A2%98/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I/"/>
      <url>/2022/10/28/%E7%AE%97%E6%B3%95%E9%A2%98/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I/</url>
      
        <content type="html"><![CDATA[<p><code>nums1</code> 中数字 <code>x</code> 的 下一个更大元素 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 右侧 的 第一个 比 <code>x</code> 大的元素。</p><p>给你两个 没有重复元素 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从<code>0</code> 开始计数，其中 <code>nums1</code> 是 <code>nums2</code> 的子集。</p><p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p><p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 下一个更大元素 。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：nums1 = [4,1,2], nums2 = [1,3,4,2].输出：[-1,3,-1]解释：nums1 中每个值的下一个更大元素如下所述：- 4 ，在nums2 的第三个位子 右边不存在下一个更大元素，所以答案是 -1 。- 1 ，在nums2 的第一个位子 下一个更大元素是 3 。- 2 ，在nums2 的第四个位子 不存在下一个更大元素，所以答案是 -1 。</code></pre><p>示例 2：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="symbol">nums1</span> = [<span class="number">2</span>,<span class="number">4</span>], <span class="symbol">nums2</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">-1</span>]</span><br><span class="line">解释：<span class="symbol">nums1</span> 中每个值的下一个更大元素如下所述：</span><br><span class="line">- <span class="number">2</span> ，在<span class="symbol">nums2</span> 的第二个位子 下一个更大元素是 <span class="number">3</span> 。</span><br><span class="line">- <span class="number">4</span> ，在<span class="symbol">nums2</span> 的第四个位子 不存在下一个更大元素，所以答案是 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure><h2 id="思路：单调栈-哈希表"><a href="#思路：单调栈-哈希表" class="headerlink" title="思路：单调栈 + 哈希表"></a>思路：单调栈 + 哈希表</h2><p>暴力解题就不搞了 n^2 ，谁都会，现在我们得降低时间复杂度。</p><p>单调栈，听名字就知道，这个栈保存的数据全是单调递增或递减的。</p><p>那怎么做出这种栈呢？即当一个元素想要加入前，与栈顶元素相比，比这个元素小的全部移除。</p><p>我们从后往前遍历 <code>nums2</code> 这个数组，将每个元素加入栈中。(加入时，已经把比元素大的移除了)</p><ul><li>若加入时，这个栈是空的，则说明这个元素在 <code>nums2</code> 数组的右侧没有比他更大的元素。在 哈希表 中记录为 <code>-1</code>；</li><li>若加入时，这个栈不空，则说明这个元素在 <code>nums2</code> 数组的右侧有比他更大的元素。在 哈希表 中记录为栈顶元素的大小；</li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>int* nextGreaterElement(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize)&#123;    *returnSize = nums1Size;    int *ans = malloc (nums1Size*sizeof(int));    int *stack = malloc (nums2Size*sizeof(int));    int top = 0;//定义栈。    int hash[10001];    memset (hash,-1,sizeof(hash));    for (int i = nums2Size - 1;i &gt;= 0;i--)&#123;        //移除栈顶比该元素小的元素。        while (top != 0 &amp;&amp; nums2[i] &gt; stack[top-1])            top--;        if (top != 0)            hash[nums2[i]] = stack[top-1];        //将元素加入栈中。        stack[top++] = nums2[i];    &#125;    for(int i = 0;i &lt; nums1Size;i++)&#123;        ans[i] = hash[nums1[i]];    &#125;    return ans;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (m * n)</code>。 m,n 分别为 nums1 和 nums2 的长度。</li><li>空间复杂度：<code>O (m + n)</code>。 栈的大小以及哈希表所占空间，因为c语言没有哈希表这个数据结构，所以哈希表的申请空间有点奇怪。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子数组的最小值之和</title>
      <link href="/2022/10/28/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C/"/>
      <url>/2022/10/28/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数数组 <code>arr</code>，找到 <code>min(b)</code> 的总和，其中 <code>b</code> 的范围为 <code>arr</code> 的每个（连续）子数组。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = <span class="comment">[3,1,2,4]</span></span><br><span class="line">输出：17</span><br><span class="line">解释：</span><br><span class="line">子数组为 <span class="comment">[3]</span>，<span class="comment">[1]</span>，<span class="comment">[2]</span>，<span class="comment">[4]</span>，<span class="comment">[3,1]</span>，<span class="comment">[1,2]</span>，<span class="comment">[2,4]</span>，<span class="comment">[3,1,2]</span>，<span class="comment">[1,2,4]</span>，<span class="comment">[3,1,2,4]</span>。 </span><br><span class="line">最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = <span class="string">[11,81,94,43,3]</span></span><br><span class="line">输出：<span class="number">444</span></span><br></pre></td></tr></table></figure><p>提示：</p><p><code>1 &lt;= arr.length &lt;= 3 * 104</code><br><code>1 &lt;= arr[i] &lt;= 3 * 104</code></p><h2 id="思路一：暴力"><a href="#思路一：暴力" class="headerlink" title="思路一：暴力"></a>思路一：暴力</h2><p>计算出每个子数组的最小值进行相加<br>先计算长度为1的保存至数组SubarrayMin中，每次增加一个长度，i即为此时子数组长度。遍历，所有值相加。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="built_in">min</span>(a,b) (a &gt; b ? b : a)</span><br><span class="line"><span class="built_in">int</span> sumSubarrayMins(<span class="built_in">int</span>* arr, <span class="built_in">int</span> arrSize)&#123;</span><br><span class="line">    <span class="built_in">int</span> SubarrayMin[arrSize];</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arrSize;i++)&#123;</span><br><span class="line">        SubarrayMin[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arrSize;i++)&#123;</span><br><span class="line">        for(<span class="built_in">int</span> j = <span class="number">0</span>; i + j &lt; arrSize;j++)&#123;</span><br><span class="line">            SubarrayMin[j] = <span class="built_in">min</span>(SubarrayMin[ j ],arr[j + i]);</span><br><span class="line">            <span class="built_in">sum</span> += SubarrayMin[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n ^ 2)</code>。 </li><li>空间复杂度：<code>O (n)</code> 。</li></ul><h2 id="思路二：单调栈"><a href="#思路二：单调栈" class="headerlink" title="思路二：单调栈"></a>思路二：单调栈</h2><p>关于【<a href="">单调栈</a>】可以参考 <a href="./%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I.md">下一个最大元素｜题解</a></p><p>暴力解题的思路就是找到所有的子数组中的最小值，然后进行相加。</p><p>那么我们这就换一种思路，找到数组中的每一个元素可以在多少个子数组中充当最小值。把这个子数组的个数求出，乘以他的值，累加，即可求解。</p><p>我们先看元素 <code>arr[i]</code>，是不是只需要分别找到他的左边第一个比他大的值（下标 <code>i</code> ），和右边第一个比他大的值（下标 <code>j</code>），在下标 <code>[i,j]</code> 之间的子数组，只要 <code>arr[i]</code> 在这里面是不是就是最小的？</p><p>接下来就是找 <code>i</code> 和 <code>j</code> 了：</p><ul><li>创建单调递增栈，先从前往后遍历，将数组元素的下标（x）保存至栈中，在元素进去前，将比他大的元素移除，直到栈中所有元素都不比他大，则此时栈顶元素就是要找的 <code>i</code>,我们将 <code>x - i</code>保存至数组 <code>left[x]</code> 中。</li><li>再将栈重置，从后往前遍历，将数组元素的下标（x）保存至栈中，在元素进去前，，为了避免多算以及少算，将不小于他的元素移除，直到栈中所有元素都小于他，就能找到 <code>j</code> 我们将 <code>j - x</code> 保存至数组 <code>right[x]</code> 中。</li><li>那么下标为 <code>x</code> 的元素所在的子数组就共有 <code>left[x] * right[x]</code> 个。</li></ul><p>个数乘以元素，加入到sum中即可。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumSubarrayMins</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> arrSize)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> left[arrSize],right[arrSize];</span><br><span class="line">    <span class="type">int</span> stack[arrSize],top = <span class="number">0</span>;<span class="comment">//构建单调递减栈，栈中记录数据所在数据的下标</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize;i++)&#123;</span><br><span class="line">        <span class="comment">//移除比该元素大的数</span></span><br><span class="line">        <span class="keyword">while</span> (top != <span class="number">0</span> &amp;&amp; arr[i] &lt;= arr[stack[top<span class="number">-1</span>]])</span><br><span class="line">            top--;</span><br><span class="line">        <span class="keyword">if</span> (top != <span class="number">0</span>)</span><br><span class="line">            left[i] = i - stack[top <span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            left[i] = i + <span class="number">1</span>; </span><br><span class="line">        <span class="comment">//将元素下标加入栈中</span></span><br><span class="line">        stack[top++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    top = <span class="number">0</span>;<span class="comment">//初始化栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = arrSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span> (top != <span class="number">0</span> &amp;&amp; arr[i] &lt; arr[stack[top<span class="number">-1</span>]])</span><br><span class="line">            top--;</span><br><span class="line">        <span class="keyword">if</span> (top != <span class="number">0</span>)</span><br><span class="line">            right[i] = stack[top<span class="number">-1</span>] - i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right[i] = arrSize - i;</span><br><span class="line">        stack[top++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; arrSize;i++ )&#123;</span><br><span class="line">        sum += arr[i] * left[i] * right[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。遍历三次数组 </li><li>空间复杂度：<code>O (n)</code>。栈，left数组，right数组。</li></ul><h2 id="思路三：动态规划"><a href="#思路三：动态规划" class="headerlink" title="思路三：动态规划"></a>思路三：动态规划</h2><p>上面就是只利用了单调栈来解决问题，其实还可以再用动态规划来解决问题。</p><p>我们要解决 长度为 <code>i</code> 的问题，可以看成 长度为 <code>i-1</code> 数组又加了一个元素在尾端，那么子数组就增加了i个，现在就是要求这i个数组的最小值之和的问题。那这i个数组都是以arr[i]为最右端的数组，那我们先找到离 <code>arr[i]</code> 最近且比 <code>arr[i]</code> 小的 <code>arr[k]</code>。</p><p>这 <code>i</code> 个数组分成两部分，第一部分是不含 <code>arr[k]</code> 的那部分，第二部分是含 <code>arr[k]</code> 的部分。</p><p>第一部分的最小值之和很容易求，为 <code>i-k * arr[i]</code>。</p><p>第二部分，含 <code>arr[k]</code> 下标那部分单独拎出来看，是不是和 在数组前 <code>k-1</code> 个元素在尾端加入 第 <code>k</code> 个元素的 最小值之和 相等呢？</p><p><img src="/./../img/%E6%88%AA%E5%B1%8F2022-10-30%20%E4%B8%8A%E5%8D%881.31.16.png"></p><p>数组数量一样，数组前 <code>k + 1</code> 个元素一样，<code>arr[k+1]~arr[i]</code> 中没有比 <code>arr[k]</code> 最小的数。</p><p>是不是就有以下的动态规划公式？</p><blockquote><p>dp[i] &#x3D; k*arr[i] + dp[i−k];</p></blockquote><p>这个k下标寻找的方法和方法二一样，就是利用单调栈。</p><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><pre><code>int sumSubarrayMins(int* arr, int arrSize) &#123;    int ans = 0;    int monoStack[arrSize], dp[arrSize];    int top = 0;    for (int i = 0; i &lt; arrSize; i++) &#123;        while (top &gt; 0 &amp;&amp; arr[monoStack[top - 1]] &gt; arr[i]) &#123;            top--;        &#125;        int k = top == 0 ? (i + 1) : (i - monoStack[top - 1]);        //递推公式        dp[i] = k * arr[i] + (top == 0 ? 0 : dp[i - k]);        //求和        ans += dp[i];        monoStack[top++] = i;    &#125;    return ans;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。遍历一次数组</li><li>空间复杂度：<code>O (n)</code>。单调栈以及数组dp。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>和至少为 K 的最短子数组</title>
      <link href="/2022/10/26/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BA-K-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2022/10/26/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BA-K-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，找出 <code>nums</code> 中和至少为 <code>k</code> 的 <strong>最短非空子数组</strong> ，并返回该子数组的长度。如果不存在这样的 <strong>子数组</strong> ，返回 <code>-1</code> 。</p><p><strong>子数组</strong> 是数组中 <strong>连续</strong> 的一部分。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1], k = 1</span></span><br><span class="line"><span class="string">输出：1</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1,2], k = 4</span></span><br><span class="line"><span class="string">输出：-1</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [2,-1,2], k = 3</span></span><br><span class="line"><span class="string">输出：3</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li><li><code>1 &lt;= k &lt;= 109</code></li></ul><h2 id="思路一：暴力"><a href="#思路一：暴力" class="headerlink" title="思路一：暴力"></a>思路一：暴力</h2><p>暴力解题，没什么好说的，但存在着问题。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> shortestSubarray(<span class="built_in">int</span>* nums, <span class="built_in">int</span> numsSize, <span class="built_in">int</span> k)&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">min</span> = numsSize + <span class="number">1</span>;</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; numsSize;i++)&#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>,j;</span><br><span class="line">        for(j = i;<span class="built_in">sum</span> &lt; k &amp;&amp; j &lt; numsSize;j++)&#123;</span><br><span class="line">            <span class="built_in">sum</span> += nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sum</span> &gt;= k)&#123;</span><br><span class="line">            <span class="built_in">min</span> = <span class="built_in">min</span> &lt; (j - i) ? <span class="built_in">min</span> : (j - i); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">min</span> == numsSize + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n^2)</code>。在这种时间复杂度下，他的运行时间有可能超时，所以该方法不可取。</li><li>空间复杂度：<code>O (1)</code>。</li></ul><h2 id="思路二：前缀和-单调队列"><a href="#思路二：前缀和-单调队列" class="headerlink" title="思路二：前缀和 + 单调队列"></a>思路二：前缀和 + 单调队列</h2><p>创建一个数组 <code>preSumArr</code> 用来保存 <code>nums</code> 数组的前缀和。<br>然后使用前缀和的差来计算 子数组 的和，对应的长度就是两个前缀和的下标差。</p><p>那么怎么减少运算量呢？</p><p>需要理清下面两点(<code>a</code> &#x3D; <code>preSumArr[i+m]</code>,<code>b</code> &#x3D; <code>preSumArr[i]</code>)：</p><ul><li>当出现 <code>a - b &gt;= k</code> 时，是不是 <code>a</code> 后面的数据就不用和 <code>b</code> 数据进行比较了，因为无论怎么比他们的子数组都比 <code>m</code> 大。所以，<code>i</code> 位置的数据就用不着了。 </li><li>当 <code>a</code> 与 <code>b</code> 之间存在着一个数 <code>c</code> 比 <code>b</code> 小。那么如果 <code>a - b &gt;= k</code> 成立，那么一定会有 <code>a - c &gt;= k</code> 成立，子数组的长度是不是比 <code>m</code> 小？所以当出现了这么个数 <code>c</code> 时，<code>i</code> 位置的数据就用不着了 。</li></ul><p>根据以上2点可以创建一个队列 <code>queue</code> 用来增、删前缀和数组的元素，只记录下标。</p><p>拿出数组 <code>preSumArr</code> 的元素，和队列最前的元素相比较。</p><p>若差大于等于 <code>k</code> ，则删除队列中的该元素，直到队列中所有的数与其差值都小于 <code>k</code>。</p><p>此时再将数组元素加入至队列中，并将队列中比其大的元素删除。</p><blockquote><p>此时思考一点，我们每次将数组元素加入队列前，都把比他大的元素删除，那么这个队列从始至终不都是一个递增排列的吗？</p></blockquote><p>所以删除元素都很简单，只需要移动队列的前后指针即可。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> min(a,b) (a &lt; b ? a : b);</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shortestSubarray</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = numsSize + <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> preSumArr[numsSize+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> queue[numsSize+<span class="number">1</span>],front = <span class="number">0</span>,rear = <span class="number">0</span>;</span><br><span class="line">    preSumArr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算数组sums的前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; numsSize;i++)&#123;</span><br><span class="line">        preSumArr[i+<span class="number">1</span>] = preSumArr[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= numsSize;i++)&#123;</span><br><span class="line">        <span class="type">long</span> n = preSumArr[i];</span><br><span class="line">        <span class="comment">//删除队列的元素</span></span><br><span class="line">        <span class="keyword">while</span> ( rear != front &amp;&amp; n - preSumArr[queue[front]] &gt;= k)&#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans,i - queue[front]);</span><br><span class="line">            front++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除队列中比 n 大的数</span></span><br><span class="line">        <span class="keyword">while</span> ( rear != front &amp;&amp; n &lt;= preSumArr[queue[rear<span class="number">-1</span>]])&#123;</span><br><span class="line">            rear--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数加入队列</span></span><br><span class="line">        queue[rear] = i;</span><br><span class="line">        rear ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans &gt; numsSize ? <span class="number">-1</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。</li><li>空间复杂度：<code>O (n)</code>。申请了两个长度为n的数组</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短的桥</title>
      <link href="/2022/10/25/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5/"/>
      <url>/2022/10/25/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5/</url>
      
        <content type="html"><![CDATA[<p>给你一个大小为 <code>n * n</code> 的二元矩阵 <code>grid</code> ，其中 <code>1</code> 表示陆地，<code>0</code> 表示水域。</p><p>岛是由一片为的 <code>1</code> 形成的一个最大组，即不会与非组内的任何其他 <code>1</code> 相连。<code>grid</code> 中 恰好存在两座岛 。</p><p>你可以将任意数量的 <code>0</code> 变为 <code>1</code> ，以使两座岛连接起来，变成 一座岛 。</p><p>返回必须翻转的 <code>0</code> 的最小数目。</p><p> <span id="more"></span></p><p>示例 1：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="string">[[0,1],[1,0]]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="string">[[0,1,0],[0,0,0],[0,0,1]]</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="comment">[<span class="comment">[1,1,1,1,1]</span>,<span class="comment">[1,0,0,0,1]</span>,<span class="comment">[1,0,1,0,1]</span>,<span class="comment">[1,0,0,0,1]</span>,<span class="comment">[1,1,1,1,1]</span>]</span></span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h2 id="思路一：广度优先搜索"><a href="#思路一：广度优先搜索" class="headerlink" title="思路一：广度优先搜索"></a>思路一：广度优先搜索</h2><p>题目中求最少的翻转 <code>0</code> 的数目等价于求矩阵中两个岛的最短距离，因此我们可以广度优先搜索来找到矩阵中两个块的最短距离。首先找到其中一座岛，然后将其不断向外延伸一圈，直到到达了另一座岛，延伸的圈数即为最短距离。广度优先搜索时，我们可以将已经遍历过的位置标记为 <code>−1</code>，实际计算过程如下：</p><ul><li>我们通过遍历找到数组 <code>grid</code> 中的 <code>1</code> 后进行广度优先搜索，此时可以得到第一座岛的位置集合，记为 <code>island</code> ，并将其位置全部标记为 <code>−1</code>。</li><li>随后我们从 <code>island</code> 中的所有位置开始进行广度优先搜索，当它们到达了任意的 <code>1</code> 时，即表示搜索到了第二个岛，搜索的层数就是答案。</li></ul><p>别看代码长，其实很容易理解。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> shortestBridge(<span class="built_in">int</span>** grid, <span class="built_in">int</span> gridSize, <span class="built_in">int</span>* gridColSize) &#123;</span><br><span class="line">    <span class="built_in">int</span> n = gridSize;</span><br><span class="line">    <span class="built_in">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//构造一个 island 和队列 queue，island记录第一块岛。</span></span><br><span class="line">    <span class="built_in">int</span> *island = (<span class="built_in">int</span> *)malloc(sizeof(<span class="built_in">int</span>) * n * n); </span><br><span class="line">    <span class="built_in">int</span> *queue = (<span class="built_in">int</span> *)malloc(sizeof(<span class="built_in">int</span>) * n * n);</span><br><span class="line">    <span class="built_in">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 队列记录第一次出现值为 1 的坐标 (i,j)</span></span><br><span class="line">                queue[tail++] = i * n + j;</span><br><span class="line">                grid[i][j] = <span class="number">-1</span>;</span><br><span class="line">                <span class="built_in">int</span> islandSize = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">                    <span class="comment">// (x,y) 即是记录的 (i,j)</span></span><br><span class="line">                    <span class="built_in">int</span> x = queue[head] / n;</span><br><span class="line">                    <span class="built_in">int</span> y = queue[head] % n;</span><br><span class="line">                    island[islandSize++] = queue[head];</span><br><span class="line">                    head++;</span><br><span class="line">                    <span class="comment">//搜索值为 1 周围 4 个方块是否有 1， 如果有则将值为 1 的坐标添加到队列 queue</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="built_in">int</span> nx = x + dirs[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="built_in">int</span> ny = y + dirs[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="comment">// 考虑边界问题，判断坐标(x,y)的周围4个坐标是否出界</span></span><br><span class="line">                        <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] == <span class="number">1</span>) &#123;</span><br><span class="line">                            queue[tail++] = nx * n + ny;</span><br><span class="line">                            grid[nx][ny] = <span class="number">-1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//刚已经把 所有值为 1 的坐标全部记录进数组 island 中，并且把值修改为 -1；</span></span><br><span class="line">                <span class="comment">//现在要将其中一块岛屿 island 中所有坐标加载到队列中，</span></span><br><span class="line">                head = tail = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; islandSize; i++) &#123;</span><br><span class="line">                    queue[tail++] = island[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">int</span> step = <span class="number">0</span>;<span class="comment">//step记录需要翻转 0 的个数。</span></span><br><span class="line">                <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">                    <span class="comment">//接下来就是将 值为 -1 的坐标周围一圈的 0 全翻转为 -1。sz 为队列长度</span></span><br><span class="line">                    <span class="built_in">int</span> sz = tail - head;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                        <span class="built_in">int</span> x = queue[head] / n;</span><br><span class="line">                        <span class="built_in">int</span> y = queue[head] % n;</span><br><span class="line">                        head++;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                            <span class="built_in">int</span> nx = x + dirs[k][<span class="number">0</span>];</span><br><span class="line">                            <span class="built_in">int</span> ny = y + dirs[k][<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n) &#123;</span><br><span class="line">                                <span class="comment">//开始翻转 0 ；</span></span><br><span class="line">                                <span class="keyword">if</span> (grid[nx][ny] == <span class="number">0</span>) &#123;</span><br><span class="line">                                    queue[tail++] = nx * n + ny;</span><br><span class="line">                                    grid[nx][ny] = <span class="number">-1</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[nx][ny] == <span class="number">1</span>) &#123;</span><br><span class="line">                                    <span class="comment">//如果在这片区域搜寻到 1 则说明已经翻转完成</span></span><br><span class="line">                                    free(queue);</span><br><span class="line">                                    free(island);</span><br><span class="line">                                    <span class="keyword">return</span> step;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    step++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O(n^2)</code></li></ul><h2 id="思路二：深度优先搜索-广度优先搜索"><a href="#思路二：深度优先搜索-广度优先搜索" class="headerlink" title="思路二：深度优先搜索 + 广度优先搜索"></a>思路二：深度优先搜索 + 广度优先搜索</h2><p>解法思路与思路一类似，我们可以利用深度优先搜索求出其中的一座岛，然后利用广度优先搜索来找到两座岛的最短距离。深度度优先搜索时，我们可以将已经遍历过的位置标记为 <code>−1</code>，实际计算过程如下：</p><ul><li>我们通过遍历找到数组 <code>grid</code> 中的 <code>1</code> 后进行深度优先搜索，此时可以得到第一座岛的位置集合，记为 <code>island</code> ，并将其位置全部标记为 <code>−1</code>。</li><li>随后我们从 <code>island</code> 中的所有位置开始进行广度优先搜索，当它们到达了任意的 <code>1</code> 时，即表示搜索到了第二个岛，搜索的层数就是答案。</li></ul><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*该函数所表达的意思：</span></span><br><span class="line"><span class="comment">    坐标(x,y) 的值为 1 则加入至队列 queue 中，</span></span><br><span class="line"><span class="comment">    坐标(x,y) 周围与之相连的 1 也加入至队列 queue 中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">void</span> dfs(<span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="built_in">int</span>** grid, <span class="built_in">int</span> n, <span class="built_in">int</span> *queue, <span class="built_in">int</span> *tail) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= n || y &gt;= n || grid[x][y] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[(*tail)++] = x * n + y;</span><br><span class="line">    grid[x][y] = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//四个dfs函数对应了4个方向的坐标</span></span><br><span class="line">    dfs(x - <span class="number">1</span>, y, grid, n, queue, tail);</span><br><span class="line">    dfs(x + <span class="number">1</span>, y, grid, n, queue, tail);</span><br><span class="line">    dfs(x, y - <span class="number">1</span>, grid, n, queue, tail);</span><br><span class="line">    dfs(x, y + <span class="number">1</span>, grid, n, queue, tail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> shortestBridge(<span class="built_in">int</span>** grid, <span class="built_in">int</span> gridSize, <span class="built_in">int</span>* gridColSize) &#123;</span><br><span class="line">    <span class="built_in">int</span> n = gridSize;</span><br><span class="line">    <span class="built_in">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">int</span> *queue = (<span class="built_in">int</span> *)malloc(sizeof(<span class="built_in">int</span>) * n * n);</span><br><span class="line">                <span class="built_in">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">                dfs(i, j, grid, n, queue, &amp;tail);</span><br><span class="line">                <span class="built_in">int</span> step = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//此时队列 queue 已经将其中一块岛的所有坐标保存下来了。</span></span><br><span class="line">                <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">                    <span class="built_in">int</span> sz = tail - head;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                        <span class="built_in">int</span> x = queue[head] / n;</span><br><span class="line">                        <span class="built_in">int</span> y = queue[head] % n;</span><br><span class="line">                        head++;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                            <span class="built_in">int</span> nx = x + dirs[k][<span class="number">0</span>];</span><br><span class="line">                            <span class="built_in">int</span> ny = y + dirs[k][<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (grid[nx][ny] == <span class="number">0</span>) &#123;</span><br><span class="line">                                    queue[tail++] = nx * n + ny;</span><br><span class="line">                                    grid[nx][ny] = <span class="number">-1</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[nx][ny] == <span class="number">1</span>) &#123;</span><br><span class="line">                                    free(queue);</span><br><span class="line">                                    <span class="keyword">return</span> step;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    step++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O(n^2)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 广度优先搜索 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复字符的最长子串</title>
      <link href="/2022/10/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2022/10/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 最长子串 的长度。</p><span id="more"></span><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="section">输出: 3 </span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;bbbbb&quot;</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;pwwkew&quot;</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p>提示：</p><p><code>0 &lt;= s.length &lt;=  5 * 104</code><br><code>s</code> 由英文字母、数字、符号和空格组成</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题主要用到思路是：滑动窗口</p><p>什么是滑动窗口？</p><p>其实就是一个队列,比如例题中的 <code>abcabcbb</code> ，进入这个队列（窗口）为 <code>abc</code> 满足题目要求，当再进入 <code>a</code>，队列变成了 <code>abca</code>，这时候不满足要求。所以，我们要移动这个队列！</p><p>如何移动？</p><p>如何才能高效地移动这个队列，使得这个队列一直满足要求呢？那就得用到哈希表。<br>创建哈希表 <code>hash</code> 记录搜索的每一个字符最后出现的位置，每当出现一个字符，就将他的位置记录下来 <code>hash[s[rear]] = rear + 1</code> ，当队列进入一个字符时，使得队列中有两个字符相同时，我们就可以利用 <code>hash</code> 表快速的将左边那个字符移出去。</p><p>一直维持这样的队列，找出队列出现最长的长度时候，即可求出解！</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="type">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hash[<span class="number">127</span>] = &#123;<span class="number">0</span>&#125;,max = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>,rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[rear])&#123;</span><br><span class="line">        <span class="comment">//当在对列front下标的右侧出现2个相同的字符时，移动front。</span></span><br><span class="line">        <span class="keyword">if</span>(front &lt; hash[s[rear]])</span><br><span class="line">            front = hash[s[rear]];</span><br><span class="line">        max = max &gt; rear + <span class="number">1</span> - front ? max : rear + <span class="number">1</span> - front;</span><br><span class="line">        hash[s[rear]] = rear + <span class="number">1</span>;</span><br><span class="line">        rear++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。n为字符串长度</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同路径II</title>
      <link href="/2022/10/23/%E7%AE%97%E6%B3%95%E9%A2%98/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/"/>
      <url>/2022/10/23/%E7%AE%97%E6%B3%95%E9%A2%98/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</url>
      
        <content type="html"><![CDATA[<p>一个机器人位于一个 <code>m * n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><span id="more"></span><p><strong>示例 1：</strong><br><img src="/./../img/robot1.jpg"></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">3</span>x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 <span class="number">2</span> 条不同的路径：</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong><br><img src="/./../img/robot2.jpg"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid = <span class="string">[[0,1],[0,0]]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><p>不同路径II 可以用<a href="./%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.md">不同路径</a>的动态规划代码完成，不过要让有障碍物的位置 <code>f[i][j]</code> 应该为 <code>0</code>。</p><p>现在还有一种叫做滚动数组，也就是说，这个数组 <code>f</code> 是在滚动的<br><br/><br>什么意思呢？就是说 <code>i = 0</code> 时的数组和 <code>i = 1</code> 时的数组表达的东西不一样，<code>i</code> 的值就代表了这个数组表示的是第 <code>i</code> 行对应的数组。</p><blockquote><p><code>f[j] = f[j - 1] + f[j]</code></p></blockquote><blockquote><p><code>f(i,j) = f(i−1,j) + f(i,j−1)</code></p></blockquote><p>两者是等价的。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int uniquePathsWithObstacles(int** obstacleGrid, int obstacleGridSize, int* obstacleGridColSize)&#123;</span><br><span class="line">    int n = obstacleGridSize, m = obstacleGridColSize<span class="comment">[0]</span>;</span><br><span class="line">    int f<span class="comment">[m]</span>;</span><br><span class="line">    memset(f, 0, sizeof(f));</span><br><span class="line">    f<span class="comment">[0]</span> = (obstacleGrid<span class="comment">[0]</span><span class="comment">[0]</span> == 0);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">            if (obstacleGrid<span class="comment">[i]</span><span class="comment">[j]</span> == 1) &#123;</span><br><span class="line">                f<span class="comment">[j]</span> = 0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (j - 1 &gt;= 0 &amp;&amp; obstacleGrid<span class="comment">[i]</span><span class="comment">[j - 1]</span> == 0) &#123;</span><br><span class="line">                f<span class="comment">[j]</span> += f<span class="comment">[j - 1]</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f<span class="comment">[m - 1]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (m * n)</code>。</li><li>空间复杂度：<code>O (m)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同路径</title>
      <link href="/2022/10/23/%E7%AE%97%E6%B3%95%E9%A2%98/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
      <url>/2022/10/23/%E7%AE%97%E6%B3%95%E9%A2%98/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p>一个机器人位于一个 <code>m * n</code> 网格的左上角（起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="/./../img/robot_maze.png"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, <span class="built_in">n</span> = <span class="number">7</span></span><br><span class="line">输出：<span class="number">28</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 <span class="number">3</span> 条路径可以到达右下角。</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line"><span class="number">3.</span> 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">7</span>, <span class="built_in">n</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">28</span></span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, <span class="built_in">n</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="解题思路-一-：动态规划"><a href="#解题思路-一-：动态规划" class="headerlink" title="解题思路(一)：动态规划"></a>解题思路(一)：动态规划</h2><p>用二维数组<code>f(i, j)</code> 表示从左上角走到 <code>(i, j)</code> 的路径数量。</p><p>由于我们每一步只能从向下或者向右移动一步，因此要想走到 <code>(i, j)</code>，如果向下走一步，那么会从 <code>(i-1, j)</code> 走过来；如果向右走一步，那么会从 <code>(i, j-1)</code> 走过来。因此我们可以写出动态规划转移方程：</p><blockquote><p><code>f(i,j) = f(i−1,j) + f(i,j−1)</code></p></blockquote><p>但是由于第一行与第一列在边界，所以只能为 <code>1</code> 。</p><p>简单的来说就像是个杨辉三角。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int uniquePaths(int m, int n) &#123;</span><br><span class="line">    int f<span class="comment">[m]</span><span class="comment">[n]</span>;</span><br><span class="line">    f<span class="comment">[0]</span><span class="comment">[0]</span> = 1;</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            if(i = 0 &amp;&amp; j &gt; 0)&#123;</span><br><span class="line">                f<span class="comment">[0]</span><span class="comment">[j]</span> = f<span class="comment">[0]</span><span class="comment">[j - 1]</span>;</span><br><span class="line">            &#125;else if(j = 0 &amp;&amp; i &gt; 0)&#123;</span><br><span class="line">                f<span class="comment">[i]</span><span class="comment">[0]</span> = f<span class="comment">[i - 1]</span><span class="comment">[0]</span>;</span><br><span class="line">            &#125;else if(i &gt; 0 &amp;&amp;j &gt; 0)&#123;</span><br><span class="line">                f<span class="comment">[i]</span><span class="comment">[j]</span> = f<span class="comment">[i - 1]</span><span class="comment">[j]</span> + f<span class="comment">[i]</span><span class="comment">[j - 1]</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f<span class="comment">[m - 1]</span><span class="comment">[n - 1]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(m * n)</code></li><li>空间复杂度：<code>O(m * n)</code></li></ul><h2 id="解题思路-二-：排列组合原理"><a href="#解题思路-二-：排列组合原理" class="headerlink" title="解题思路(二)：排列组合原理"></a>解题思路(二)：排列组合原理</h2><p>这个机器人总共需要走 <code>m + n -2</code> 步走到终点。其中有 <code>m - 1</code> 步是向下走的， <code>n - 1</code> 步是向右走的。利用排列组合知识，可以得出总共需要走 C<sub>n-1</sub><sup style="margin-left:-20px">m+n-2</sup> 步，意思就是从 <code>m + n -2</code> 步中选择 <code>n - 1</code> 步向右其余向左。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> unique<span class="constructor">Paths(<span class="params">int</span> <span class="params">m</span>, <span class="params">int</span> <span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//保证n更小。</span></span><br><span class="line">    <span class="keyword">if</span> (m &lt; n)</span><br><span class="line">        return unique<span class="constructor">Paths(<span class="params">n</span> , <span class="params">m</span>)</span>;</span><br><span class="line">    <span class="comment">//计算路径条数</span></span><br><span class="line">    <span class="built_in">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        ans = ans<span class="operator"> * </span>(m + i - <span class="number">1</span>)<span class="operator"> / </span>i; </span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(min(n,m))</code>;</li><li>空间复杂度：<code>O(1)</code>;</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串相乘</title>
      <link href="/2022/10/20/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
      <url>/2022/10/20/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
      
        <content type="html"><![CDATA[<p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p><span id="more"></span><p>注意：不能使用任何内置的 <code>BigInteger</code> 库或直接将输入转换为整数。</p><p>示例 1:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="symbol">num1</span> = <span class="string">&quot;2&quot;</span>, <span class="symbol">num2</span> = <span class="string">&quot;3&quot;</span></span><br><span class="line">输出: <span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="symbol">num1</span> = <span class="string">&quot;123&quot;</span>, <span class="symbol">num2</span> = <span class="string">&quot;456&quot;</span></span><br><span class="line">输出: <span class="string">&quot;56088&quot;</span></span><br></pre></td></tr></table></figure><p>提示：</p><p><code>1 &lt;= num1.length, num2.length &lt;= 200</code></p><p><code>num1</code> 和 <code>num2</code> 只能由数字组成。</p><p><code>num1</code> 和 <code>num2</code> 都不包含任何前导零，除了数字0本身。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>该算法是通过两数相乘时，乘数某位与被乘数某位相乘，与产生结果的位置的规律来完成。具体规律如下：</p><p>乘数 <code>num1</code> 位数为 <code>s1</code>，被乘数 <code>num2</code> 位数为 <code>s2</code>， <code>num1 x num2</code> 结果 <code>num3</code> 最大总位数为 <code>s1+s2</code><br><code>num1[i] x num2[j]</code> 的结果为 <code>value</code>(位数为两位，”0x”,”xy”的形式)，其第一位位于 <code>num3[i+j]</code>，第二位位于 <code>num3[i+j+1]</code>。</p><p>结合下图更容易理解:</p><p><img src="/./../img/171cad48cd0c14f565f2a0e5aa5ccb130e4562906ee10a84289f12e4460fe164-image.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">multiply</span><span class="params">(<span class="type">char</span> * num1, <span class="type">char</span> * num2)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s1 = <span class="built_in">strlen</span>(num1);</span><br><span class="line">    <span class="type">int</span> s2 = <span class="built_in">strlen</span>(num2);</span><br><span class="line">    <span class="type">char</span> *num3 = (<span class="type">char</span> *)<span class="built_in">malloc</span>((s1+s2+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="comment">//将num3全所有字符变为0，再在结尾加上&#x27;\0&#x27;;</span></span><br><span class="line">    <span class="built_in">memset</span>(num3,<span class="string">&#x27;0&#x27;</span>,s1 + s2 );</span><br><span class="line">    num3[s1 + s2] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//从后往前遍历，可以避免进位问题。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s1 - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = s2 - <span class="number">1</span>;j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="type">int</span> value = num3[i + j + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> + (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>) ;</span><br><span class="line">            num3[i + j] += value / <span class="number">10</span>;</span><br><span class="line">            num3[i + j + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span> + value % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分3种情况输出</span></span><br><span class="line">    <span class="keyword">if</span>(num3[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; num3[<span class="number">1</span>] &amp;&amp; num3[<span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//首位为0，但结果不为0，直接舍去第一个字符</span></span><br><span class="line">        <span class="keyword">return</span> num3 + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num3[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//结果为0输出0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//直接输出num3</span></span><br><span class="line">        <span class="keyword">return</span> num3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (M * N)</code>。 M,N 分别为 num1 和 num2 的长度。</li><li>空间复杂度：<code>O (M + N)</code>。 用于存储计算结果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缺失的第一个正数</title>
      <link href="/2022/10/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
      <url>/2022/10/19/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1,2,0]</span></span><br><span class="line"><span class="string">输出：3</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [3,4,-1,1]</span></span><br><span class="line"><span class="string">输出：2</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[7,8,9,11,12]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="思路：原地哈希表"><a href="#思路：原地哈希表" class="headerlink" title="思路：原地哈希表"></a>思路：原地哈希表</h2><br/><ul><li><p>要求时间复杂度为 <code>O(n)</code> ，很容易想到是把数组里面的所有正数放到哈希表中，再利用一次遍历即可找出缺失的最小正数。但是这样，空间复杂度就也变成了 <code>O(n)</code> 不符合题目所说的常数级了。<br>在这上面进行改进，把原有的数组空间看成一个哈希表，也就是原地哈希表。</p></li><li><p>那么，我们可以采取这样的思路：就把 <code>1</code> 这个数放到下标为 <code>0</code> 的位置， <code>2</code> 这个数放到下标为 <code>1</code> 的位置，按照这种思路整理一遍数组。然后我们再遍历一次数组，第 <code>1</code> 个遇到的它的值不等于下标的那个数，就是我们要找的缺失的第一个正数。</p></li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int firstMissingPositive(int* nums, int numsSize)&#123;</span><br><span class="line">    for(int i = 0 ; i &lt; numsSize;i++)&#123;</span><br><span class="line">        while (nums<span class="comment">[i]</span> != i + 1)&#123;</span><br><span class="line">            if (nums<span class="comment">[i]</span> &lt;= 0 || nums<span class="comment">[i]</span> &gt; numsSize || nums<span class="comment">[i]</span> == nums<span class="comment">[nums<span class="comment">[i]</span> - 1]</span>)</span><br><span class="line">                break;</span><br><span class="line">            // 将nums<span class="comment">[i]</span> 放置到对应位置上<span class="comment">[1,2,3...]</span></span><br><span class="line">            int idx = nums<span class="comment">[i]</span> - 1;</span><br><span class="line">            nums<span class="comment">[i]</span> = nums<span class="comment">[idx]</span>;</span><br><span class="line">            nums<span class="comment">[idx]</span> = idx + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; numsSize ;i++) &#123;</span><br><span class="line">        if (nums<span class="comment">[i]</span> != (i + 1)) &#123;</span><br><span class="line">            return (i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return numsSize + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。遍历了整个数组一遍。</li><li>空间复杂度：<code>O (1)</code>。原地哈希表，没有申请额外的线性空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索旋转数组</title>
      <link href="/2022/10/18/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
      <url>/2022/10/18/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>整数数组 <code>nums</code> 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 <code>k（0 &lt;= k &lt; nums.length）</code>上进行了 旋转，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 <code>0</code> 开始 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>时间复杂度必须为 O(log n)。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[4,5,6,7,0,1,2]</span>, target = <span class="number">0</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[4,5,6,7,0,1,2]</span>, target = <span class="number">3</span></span><br><span class="line">输出：-<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>], <span class="keyword">target</span> = <span class="number">0</span></span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 中的每个值都 独一无二</li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h2 id="思路：二分法"><a href="#思路：二分法" class="headerlink" title="思路：二分法"></a>思路：二分法</h2><ul><li>二分查找</li></ul><p>对于我们来说更熟悉于查找 递增数组 <code>[0,1,2,4,5,6,7]</code> 中的值。</p><p>那么对于旋转后的数组 <code>[4,5,6,7,0,1,2]</code> 我们不太熟练。所以我们就把这个数组转化成我们熟知的问题，也就是把数组 <code>[4,5,6,7,0,1,2]</code> 重新旋转回去，那么怎么做呢？</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">4,5,6,7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"> ^ ^ ^ ^</span><br><span class="line">[<span class="number">4,5,6,7</span>,<span class="number">0,1,2,4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">               ^ ^ ^ ^</span><br></pre></td></tr></table></figure><p>把数组 <code>[4,5,6,7,0,1,2]</code> 看成循环数组:<br><code>[4,5,6,7,0,1,2,4,5,6,7,0,1,2,······]</code><br>然后取出最前面的有序数组 <code>[0,1,2,4,5,6,7]</code> ，进行二分查找。<br>找到最小元素 <code>0</code> 的下标 <code>i</code> ,作为最低位，则最高位为 <code>i - 1 + numsSize</code><br>可以利用循环数组的特性: <code>a[n] = a[n % numsSize]</code><br>可以不用重新申请空间做数组，最后进行代码实现。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> <span class="keyword">target</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; numsSize;i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[i<span class="number">-1</span>]) low = i;</span><br><span class="line">    <span class="keyword">int</span> high = low - <span class="number">1</span> + numsSize;</span><br><span class="line">    <span class="comment">//利用二分法查找元素 </span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid % numsSize] &lt; <span class="keyword">target</span>)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(nums[mid % numsSize] &gt; <span class="keyword">target</span>)</span></span>&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid % numsSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。主要是遍历用的时间多，二分使用的时间是log级别的，相比于线性可以忽略不计</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K 个一组翻转链表</title>
      <link href="/2022/10/17/%E7%AE%97%E6%B3%95%E9%A2%98/K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/10/17/%E7%AE%97%E6%B3%95%E9%A2%98/K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><span id="more"></span><p><strong>示例1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="string">[2,1,4,3,5]</span></span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">[3,2,1,4,5]</span></span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>将 <code>n</code> 个节点 <code>k</code> 个 <code>k</code> 个分为一组。每一组进行一次反转。 可以查看【<a href="./%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.md">反转链表</a>】</p><ul><li><p>若不足 <code>k</code> 个节点，则直接返回 <code>head</code> </p></li><li><p>若足够 <code>k</code> 个节点，则进行下一步操作；</p></li></ul><p>最后利用递归即可完成。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line">    <span class="keyword">struct</span> ListNode *next;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="keyword">struct</span> ListNode* reverse<span class="constructor">KGroup(<span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">head</span>, <span class="params">int</span> <span class="params">k</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> ListNode *tempNode = head;</span><br><span class="line">    <span class="comment">//查看剩余长度是否大于k，若不大于则直接返回头节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span> ;i &lt; k;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (tempNode<span class="operator"> == </span>NULL)</span><br><span class="line">            return head;</span><br><span class="line">        tempNode = tempNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用来保存头节点和尾节点</span></span><br><span class="line">    <span class="keyword">struct</span> ListNode *newListHead = NULL;</span><br><span class="line">    <span class="keyword">struct</span> ListNode *newListTail = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            tempNode = head-&gt;next;</span><br><span class="line">            head-&gt;next = newListHead;</span><br><span class="line">            newListHead = head;</span><br><span class="line">            head = tempNode;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//尾节点指向的是剩余未翻转的链表的头节点。</span></span><br><span class="line">    newListTail-&gt;next = reverse<span class="constructor">KGroup(<span class="params">tempNode</span>,<span class="params">k</span>)</span>;</span><br><span class="line">    return newListHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。链表长度</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两两交换节点</title>
      <link href="/2022/10/16/%E7%AE%97%E6%B3%95%E9%A2%98/%E2%80%9C%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E8%8A%82%E7%82%B9%E2%80%9D/"/>
      <url>/2022/10/16/%E7%AE%97%E6%B3%95%E9%A2%98/%E2%80%9C%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E8%8A%82%E7%82%B9%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><span id="more"></span><p>（<a href="./K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.md" title="K 个一组翻转链表">那如果不是两两交换，有可能是前k个节点发生翻转呢？这样该怎么做？</a>）</p><p><strong>示例1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1,2,3,4</span>]</span><br><span class="line">输出：[<span class="number">2,1,4,3</span>]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p><strong>示例3:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[1]</span></span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>每2个节点为一组，先完成链表的前2个节点操作，后面每组的操作相同，将第一个节点 <code>node1</code> 和第二个节点 <code>node2</code> 发生交换，然后把第三个节点 <code>node3(node2-&gt;next)</code> 看成新的 <code>node1</code> 进行下一轮的操作。</p><h3 id="递归代码："><a href="#递归代码：" class="headerlink" title="递归代码："></a>递归代码：</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* swapPairs(struct ListNode*<span class="built_in"> head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">(head</span> == NULL ||<span class="built_in"> head</span>-&gt;<span class="keyword">next</span> == NULL) &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="built_in"> head</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode* node1 =<span class="built_in"> head</span>;</span><br><span class="line">    struct ListNode* node2 =<span class="built_in"> head</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">    node1-&gt;<span class="keyword">next</span> = swapPairs(node2-&gt;<span class="keyword">next</span>);</span><br><span class="line">    node2-&gt;<span class="keyword">next</span> =<span class="built_in"> head</span>;</span><br><span class="line">    <span class="keyword">return</span> node2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。</li><li>空间复杂度：<code>O (n)</code>。 每次使用递归都会申请两个节点空间，故空间复杂度：<code>O (n)</code>。</li></ul><h3 id="迭代代码："><a href="#迭代代码：" class="headerlink" title="迭代代码："></a>迭代代码：</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* swapPairs(struct ListNode* head) &#123;</span><br><span class="line">    struct ListNode dummyHead;</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    <span class="comment">//temp是指向头节点的那个指针</span></span><br><span class="line">    struct ListNode* temp = &amp;dummyHead;</span><br><span class="line">    <span class="comment">//当第一个节点和第二个节点不为空时。</span></span><br><span class="line">    <span class="function"><span class="title">while</span> (temp-&gt;</span><span class="function"><span class="title">next</span> != NULL &amp;&amp; temp-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next != NULL) &#123;</span><br><span class="line">        <span class="function"><span class="title">struct</span> ListNode* node1 = temp-&gt;</span>next;</span><br><span class="line">        <span class="function"><span class="title">struct</span> ListNode* node2 = temp-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next;</span><br><span class="line">        <span class="function"><span class="title">temp</span>-&gt;</span>next = node2; <span class="comment">//头节点改为第二个节点</span></span><br><span class="line">        <span class="function"><span class="title">node1</span>-&gt;</span><span class="function"><span class="title">next</span> = node2-&gt;</span>next;<span class="comment">//第一个节点的下个节点为第三个节点</span></span><br><span class="line">        <span class="function"><span class="title">node2</span>-&gt;</span>next = node1; <span class="comment">//第二个节点指向第一个节点</span></span><br><span class="line">        temp = node1; <span class="comment">//temp指向了第三个节点，将第三个节点当成第一个节点，重新开始新一轮循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    return dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并k个有序链表</title>
      <link href="/2022/10/15/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/10/15/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><h2 id="思路：递归"><a href="#思路：递归" class="headerlink" title="思路：递归"></a>思路：递归</h2><p>要解决 <code>k</code>个链表合成 的问题，就得先解决两个链表合成问题。</p><p><a href="./%E9%80%92%E5%BD%92%E4%BB%A5%E5%8F%8A%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8.md" title="合并两个链表">合并两个有序列表思路</a></p><p>已经知道两个链表怎么合成，接下来就是把每个链表两两合成。直到合成到一个链表为止。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line">    <span class="keyword">struct</span> ListNode *next;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">//合成两个链表的函数</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* merge<span class="constructor">TwoLists(<span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">l1</span>, <span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">l2</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* merge<span class="constructor">KLists(<span class="params">struct</span> ListNode<span class="operator">**</span> <span class="params">lists</span>, <span class="params">int</span> <span class="params">listsSize</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (listsSize<span class="operator"> == </span>NULL) <span class="comment">//排除0个链表合成</span></span><br><span class="line">        return NULL;</span><br><span class="line">    <span class="keyword">while</span> (listsSize &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//链表两两合成，直到合完为止。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; listsSize<span class="operator"> / </span><span class="number">2</span>;i++)&#123;</span><br><span class="line">            lists<span class="literal">[<span class="identifier">i</span>]</span> = merge<span class="constructor">TwoLists(<span class="params">lists</span>[<span class="params">i</span>] , <span class="params">lists</span>[<span class="params">listsSize</span> - <span class="params">i</span> - 1])</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        listsSize = ( listsSize + <span class="number">1</span> )<span class="operator"> / </span><span class="number">2</span>; <span class="comment">//合并完后还剩下的链表数量 </span></span><br><span class="line">    &#125;</span><br><span class="line">    return lists<span class="literal">[<span class="number">0</span>]</span>;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">//利用递归 完成两个链表的合并</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* merge<span class="constructor">TwoLists(<span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">l1</span>, <span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">l2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1<span class="operator"> == </span>NULL)&#123;</span><br><span class="line">        return l2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (l2<span class="operator"> == </span>NULL)&#123;</span><br><span class="line">        return l1;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (l1 -&gt; <span class="keyword">val</span> &lt; l2 -&gt; <span class="keyword">val</span> )&#123;</span><br><span class="line">        l1 -&gt; next = merge<span class="constructor">TwoLists(<span class="params">l1</span> -&gt; <span class="params">next</span> , <span class="params">l2</span>)</span>;</span><br><span class="line">        return l1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        l2 -&gt; next = merge<span class="constructor">TwoLists(<span class="params">l2</span> -&gt; <span class="params">next</span> , <span class="params">l1</span>)</span>;</span><br><span class="line">        return l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (kn*logk)</code>。每个元素遍历k次，使用二分思想将k个链表合并，相当于 kn*logk 。</li><li>空间复杂度：<code>O (logk)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并两个有序列表</title>
      <link href="/2022/10/15/%E7%AE%97%E6%B3%95%E9%A2%98/%E9%80%92%E5%BD%92%E4%BB%A5%E5%8F%8A%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2022/10/15/%E7%AE%97%E6%B3%95%E9%A2%98/%E9%80%92%E5%BD%92%E4%BB%A5%E5%8F%8A%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>将两个升序链表合并为一个新的 <code>升序</code> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><span id="more"></span><br/><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：list1 = <span class="comment">[1,2,4]</span>, list2 = <span class="comment">[1,3,4]</span></span><br><span class="line">输出：<span class="comment">[1,1,2,3,4,4]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：list1 = <span class="comment">[]</span>, list2 = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><h2 id="思路-一：递归"><a href="#思路-一：递归" class="headerlink" title="思路 一：递归"></a>思路 一：递归</h2><p>这个就是把所有值从小到大串起来；值更小的节点指向一个比他值更大的一个节点；</p><p>也就是说可以利用递归定义两个列表的操作：</p><blockquote><p>list1[0] + merge(list1[1],list2) list1[0] &lt; list2[0]</p><p>list2[0] + merge(list1,list2[1]) list1[0] &gt;&#x3D; list2[0]<br>​</p></blockquote><p>也就是说，两个链表头部值较小的一个节点与剩下元素的 <code>merge</code> 操作结果合并;</p><p>但也要注意排除空链表。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line">    <span class="keyword">struct</span> ListNode *next;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* merge<span class="constructor">TwoLists(<span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">list1</span>, <span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">list2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1<span class="operator"> == </span>NULL)&#123;</span><br><span class="line">        return list2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (list2<span class="operator"> == </span>NULL)&#123;</span><br><span class="line">        return list1;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (list1 -&gt; <span class="keyword">val</span> &lt; list2 -&gt; <span class="keyword">val</span> )&#123;</span><br><span class="line">        list1 -&gt; next = merge<span class="constructor">TwoLists(<span class="params">list1</span> -&gt; <span class="params">next</span> , <span class="params">list2</span>)</span>;</span><br><span class="line">        return list1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        list2 -&gt; next = merge<span class="constructor">TwoLists(<span class="params">list2</span> -&gt; <span class="params">next</span> , <span class="params">list1</span>)</span>;</span><br><span class="line">        return list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。</li><li>空间复杂度：<code>O (1)</code>。</li></ul><h2 id="思路-二：迭代"><a href="#思路-二：迭代" class="headerlink" title="思路 二：迭代"></a>思路 二：迭代</h2><p>我们也可以利用迭代来实现上面的算法。也就是说当list1 和list2 不为空时，只需要比较头节点的值的大小，小的那个节点添加到结果那里，当一个节点被添加，该链表的节点往后移一位。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    int val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *next;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>* <span class="title function_ invoke__">mergeTwoLists</span>(<span class="keyword">struct</span> <span class="title class_">ListNode</span>* list1, <span class="keyword">struct</span> <span class="title class_">ListNode</span>* list2)&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *prehead = (<span class="keyword">struct</span> <span class="title class_">ListNode</span>*)<span class="title function_ invoke__">malloc</span>(<span class="title function_ invoke__">sizeof</span>(<span class="keyword">struct</span> <span class="title class_">ListNode</span>));</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *prev = prehead;    </span><br><span class="line">    <span class="title function_ invoke__">while</span> (list1 != NULL &amp;&amp; list2 != NULL) &#123;</span><br><span class="line">        <span class="title function_ invoke__">if</span> (list1 <span class="punctuation">-&gt;</span> val &lt; list2 <span class="punctuation">-&gt;</span> val) &#123;</span><br><span class="line">            prev <span class="punctuation">-&gt;</span> next = list1;</span><br><span class="line">            list1 = list1 <span class="punctuation">-&gt;</span> next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev <span class="punctuation">-&gt;</span> next = list2;</span><br><span class="line">            list2 = list2 <span class="punctuation">-&gt;</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev <span class="punctuation">-&gt;</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">    prev <span class="punctuation">-&gt;</span> next = list1 == NULL ? list2 : list1;</span><br><span class="line">    <span class="keyword">return</span> prehead <span class="punctuation">-&gt;</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 迭代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器盛水</title>
      <link href="/2022/10/13/%E7%AE%97%E6%B3%95%E9%A2%98/%E2%80%9C%E5%AE%B9%E5%99%A8%E7%9B%9B%E6%B0%B4%E2%80%9D/"/>
      <url>/2022/10/13/%E7%AE%97%E6%B3%95%E9%A2%98/%E2%80%9C%E5%AE%B9%E5%99%A8%E7%9B%9B%E6%B0%B4%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。</p><span id="more"></span><p><strong>说明：</strong><br>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1,8,6,2</span>,<span class="number">5,4,8,3</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">49</span> </span><br><span class="line">解释：图中垂直线代表输入数组 [<span class="number">1,8,6,2</span>,<span class="number">5,4,8,3</span>,<span class="number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="number">49</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="思路一：暴力法"><a href="#思路一：暴力法" class="headerlink" title="思路一：暴力法"></a>思路一：暴力法</h2><p>遍历数组每个元素，并计算出该元素下标的数组所形成的最大储水量，并保存在另一个数组中。</p><p>易知面积公式 ： min (height[j],height[i]) * (i - j);</p><p>时间复杂度 O(n^2)</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) (a &gt; b ? a : b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a,b) (a &lt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(<span class="type">int</span>* height, <span class="type">int</span> heightSize)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> visit[heightSize];</span><br><span class="line">    <span class="built_in">memset</span>( visit , <span class="number">0</span> ,<span class="built_in">sizeof</span> (visit));</span><br><span class="line">    <span class="type">int</span> Max = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; heightSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            visit[i] = <span class="built_in">max</span>( (i - j) * <span class="built_in">min</span>(height[i],height[j]) ,visit[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Max = <span class="built_in">max</span>(Max,visit[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="思路二：双指针"><a href="#思路二：双指针" class="headerlink" title="思路二：双指针"></a>思路二：双指针</h2><p>面积是一个矩形，长乘高，那么要求面积最大，先让长最大，长最大时得出一个面积，当宽增大时，看面积是否增大。</p><p>利用双指针，一个指向数组头 <code>head</code> ，一个指向数组尾部 <code>tail</code> ，让 <code>height[head]</code> 与 <code>height[tail]</code> 中值小的那个向往间靠。</p><p>时间复杂度为O(n);</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define max(a,b) (a &gt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> maxArea(<span class="type">int</span>* height, <span class="type">int</span> heightSize)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">head</span> = <span class="number">0</span>,<span class="built_in">tail</span> = heightSize - <span class="number">1</span>,MAX = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">head</span> &lt; <span class="built_in">tail</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[<span class="built_in">tail</span>] &lt; height[<span class="built_in">head</span>]) &#123;</span><br><span class="line">            <span class="comment">//当宽变化时，求出面积，然后与最大面积相比，如果更大，则替代</span></span><br><span class="line">            MAX = <span class="built_in">max</span>(MAX, height[<span class="built_in">tail</span>] * (<span class="built_in">tail</span> - <span class="built_in">head</span>));</span><br><span class="line">            <span class="built_in">tail</span> --;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            MAX = <span class="built_in">max</span>(MAX, height[<span class="built_in">head</span>] * (<span class="built_in">tail</span> - <span class="built_in">head</span>));</span><br><span class="line">            <span class="built_in">head</span> ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找数组中的中位数</title>
      <link href="/2022/10/10/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2022/10/10/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong>。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[1,3]</span>, nums2 = <span class="comment">[2]</span></span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = <span class="comment">[1,2,3]</span> ，中位数 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="symbol">nums1</span> = [<span class="number">1</span>,<span class="number">2</span>], <span class="symbol">nums2</span> = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2.50000</span></span><br><span class="line">解释：合并数组 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] ，中位数 <span class="comment">(2 + 3)</span> / <span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>由于题目中要求时间复杂度为 <code>O(log (m+n))</code> 使用普通的遍历方法肯定是达不到要求的。要产生log的话一般是要使用二分法来解题。</p><br/><ul><li>二分法</li></ul><p>把两个数组的所有数据平均分成两个数组，用两个板隔开，两个板的左边一个，右边为一个。<br>两个板的位置分别记为 <code>array1</code> 和 <code>array2</code> 那么要找到中位数，只需要保证<br>第一块板左边最大的数 小于 第二块板右边最小的数 即 <code>Lmax1 &lt; Rmin2</code> 和<br>第二块板左边最大的数 小于 第一块板右边最小的数 即 <code>Lmax2 &lt; Rmin1</code> 。</p><p>那么现在就是两块板放置的问题，我们一开始把两个板放在两个数组的最中间，<br>当 <code>Lmax1 &gt; Rmin2</code>时，第一块板往左移，使 <code>Lmax1</code> 变小。同理 当 <code>Lmax2 &gt; Rmin1</code> 时，第一块板往右移，使 <code>Rmin1</code> 变小。<br>因为要保证板两边的数量相同，那么第一块板向左移多少，第二块板就得往反方向移多少，<br>即 <code>array1 + array2 = m + n</code> 。<br>移动板，直到满足 <code>Lmax1 &lt; Rmin2 &amp;&amp; Lmax2 &lt; Rmin1</code> 。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#define max(a,b) (a &gt; b ? a : b)</span><br><span class="line">#define min(a,b) (a &lt; b ? a : b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> findMedianSortedArrays(<span class="built_in">int</span>* nums1, <span class="built_in">int</span> nums1Size, <span class="built_in">int</span>* nums2, <span class="built_in">int</span> nums2Size)&#123;</span><br><span class="line">    <span class="built_in">int</span> n = nums1Size, m = nums2Size;</span><br><span class="line">    <span class="comment">//确保第一个数组最短。</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; m)&#123;</span><br><span class="line">        <span class="keyword">return</span> findMedianSortedArrays(nums2, m,  nums1, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> Lmax1,Lmax2,Rmin1,Rmin2,<span class="built_in">array</span>1,<span class="built_in">array</span>2,head = <span class="number">0</span>,tail = <span class="number">2</span> * n;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail)&#123;</span><br><span class="line">        <span class="built_in">array</span>1 = (head + tail) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">array</span>2 = n + m - <span class="built_in">array</span>1;</span><br><span class="line"></span><br><span class="line">        Lmax1 = (<span class="built_in">array</span>1 == <span class="number">0</span>) ? INT_MIN : nums1[(<span class="built_in">array</span>1 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">        Rmin1 = (<span class="built_in">array</span>1 == <span class="number">2</span> * n) ? INT_MAX : nums1[<span class="built_in">array</span>1 / <span class="number">2</span>];</span><br><span class="line">        Lmax2 = (<span class="built_in">array</span>2 == <span class="number">0</span>) ? INT_MIN : nums2[(<span class="built_in">array</span>2 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">        Rmin2 = (<span class="built_in">array</span>2 == <span class="number">2</span> * m) ? INT_MAX : nums2[<span class="built_in">array</span>2 / <span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (Lmax1 &gt; Rmin2)&#123;</span><br><span class="line">            tail = <span class="built_in">array</span>1 - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (Lmax2 &gt; Rmin1)&#123;</span><br><span class="line">            head = <span class="built_in">array</span>1 + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  ( max(Lmax1,Lmax2) + min(Rmin1,Rmin2) ) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (log(m + n))</code>。</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/2022/10/04/Markdown/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/10/04/Markdown/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><p>相比WYSIWYG编辑器</p><p><strong>优点：</strong></p><ol><li><p>因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。</p></li><li><p>操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可</p></li></ol><br/><p><strong>缺点：</strong></p><ol><li><p>需要记一些语法（当然，是很简单。五分钟学会）。</p></li><li><p>有些平台不支持Markdown编辑模式。</p></li></ol> <span id="more"></span><br/><p>还好，简书是支持Markdown编辑模式的。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开启方式：设置-&gt;默认编辑器-&gt;Markdown编辑器</span><br></pre></td></tr></table></figure><h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><p>在想要设置为标题的文字前面加#来表示</p><p>一个#是一级标题，二个#是二级标题，以此 <code>类推</code>。支持六级标题。</p><br/> <p>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。</p><br/><p>示例：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure><p>效果如下：</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><hr><h1 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h1><ul><li><strong>加粗</strong></li></ul><p>要加粗的文字左右分别用两个*号包起来</p><ul><li><strong>斜体</strong></li></ul><p>要倾斜的文字左右分别用一个*号包起来</p><ul><li><strong>斜体加粗</strong></li></ul><p>要倾斜和加粗的文字左右分别用三个*号包起来</p><ul><li><strong>删除线</strong></li></ul><p>要加删除线的文字左右分别用两个~~号包起来</p><br/><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**这是加粗的文字**</span></span><br><span class="line"><span class="emphasis">*这是倾斜的文字*</span>`</span><br><span class="line"><span class="strong">**<span class="emphasis">*这是斜体加粗的文字*</span>**</span></span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><strong>这是加粗的文字</strong></p><p><em>这是倾斜的文字</em>&#96;</p><p><em><strong>这是斜体加粗的文字</strong></em></p><p><del>这是加删除线的文字</del></p><h1 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h1><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;</p><p>n个…</p><p>貌似可以一直加下去，但没神马卵用</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">这是引用的内容</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;这是引用的内容</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h1 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h1><p>三个或者三个以上的 - 或者 * 都可以。</p><p>示例：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">---</span></span><br><span class="line"><span class="section">----</span></span><br><span class="line"><span class="bullet">***</span></span><br><span class="line"><span class="bullet"></span><span class="strong">*****</span></span><br></pre></td></tr></table></figure><h2 id="效果如下："><a href="#效果如下：" class="headerlink" title="效果如下："></a>效果如下：</h2><hr><hr><hr><p>可以看到，显示效果是一样的。</p><h1 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h1><p><strong>语法：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 <span class="string">&#x27;&#x27;</span>图片titl<span class="string">e&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="selector-attr">[blockchain]</span>(./../img/<span class="number">6860761</span>-fd2f51090a890873<span class="selector-class">.webp</span> <span class="string">&quot;区块链&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><p><img src="/./../img/6860761-fd2f51090a890873.webp" alt="blockchain" title="区块链"></p><p><strong>上传本地图片直接点击导航栏的图片标志，选择图片即可</strong></p><br/><h1 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h1><p><strong>语法：</strong></p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接<span class="built_in">title</span>&quot;)</span><br><span class="line"><span class="built_in">title</span>可加可不加</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[简书]</span>(<span class="attribute">http</span>:<span class="comment">//jianshu.com)</span></span><br><span class="line">[百度](<span class="attribute">http</span>:<span class="comment">//baidu.com)</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="http://jianshu.com/">简书</a><br><a href="http://baidu.com/">百度</a></p><p>注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a <span class="attribute">href</span>=<span class="string">&quot;超链接地址&quot;</span> <span class="attribute">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;超链接名&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">&lt;a <span class="attribute">href</span>=<span class="string">&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot;</span> <span class="attribute">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;简书&lt;/a&gt;</span><br></pre></td></tr></table></figure><h1 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h1><p><strong>无序列表</strong></p><p>语法：</p><p>无序列表用 - + * 任何一种都可以</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 列表内容</span><br><span class="line"><span class="bullet">+</span> 列表内容</span><br><span class="line"><span class="bullet">*</span> 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + <span class="emphasis">* 跟内容之间都要有一个空格</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><p><strong>有序列表</strong></p><p>语法：</p><p>数字加点</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 列表内容</span><br><span class="line"><span class="bullet">2.</span> 列表内容</span><br><span class="line"><span class="bullet">3.</span> 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure><p>效果如下：</p><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><p><strong>列表嵌套</strong></p><p><strong>上一级和下一级之间敲三个空格即可</strong></p><ul><li><p>一级无序列表内容</p><ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li><p>一级无序列表内容</p><ol><li>二级有序列表内容</li><li>二级有序列表内容</li><li>二级有序列表内容</li></ol></li></ul><ol><li><p>一级有序列表内容</p><ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li><p>一级有序列表内容</p><ul><li>二级有序列表内容</li><li>二级有序列表内容</li><li>二级有序列表内容</li></ul></li></ol><br/><hr><h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><p>语法：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|<span class="string">表头</span>|<span class="string">表头</span></span><br><span class="line"><span class="string">---</span>|<span class="string">:--:</span>|<span class="string">---:</span></span><br><span class="line"><span class="string">内容</span>|<span class="string">内容</span>|<span class="string">内容</span></span><br><span class="line"><span class="string">内容</span>|<span class="string">内容</span>|<span class="string">内容</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第二行分割表头和内容。</span></span><br><span class="line"><span class="string">- 有一个就行，为了对齐，多加了几个</span></span><br><span class="line"><span class="string">文字默认居左</span></span><br><span class="line"><span class="string">-两边加：表示文字居中</span></span><br><span class="line"><span class="string">-右边加：表示文字居右</span></span><br><span class="line"><span class="string">注：原生的语法两边都要用 </span>|<span class="string"> 包起来。此处省略</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名|<span class="string">技能</span>|<span class="string">排行</span></span><br><span class="line"><span class="string">--</span>|<span class="string">:--:</span>|<span class="string">--:</span></span><br><span class="line"><span class="string">刘备</span>|<span class="string">哭</span>|<span class="string">大哥</span></span><br><span class="line"><span class="string">关羽</span>|<span class="string">打</span>|<span class="string">二哥</span></span><br><span class="line"><span class="string">张飞</span>|<span class="string">骂</span>|<span class="string">三弟</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><br/><h1 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h1><p>语法：</p><p>单行代码：代码之间分别用一个反引号包起来</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`代码内容`</span></span><br></pre></td></tr></table></figure><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><blockquote><p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中<br>去掉两边小括号即可。</p></blockquote><p>示例：</p><p>单行代码</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">create</span> <span class="keyword">database</span> hero;`</span><br></pre></td></tr></table></figure><p>代码块</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line">    function <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">         echo <span class="string">&quot;这是一句非常牛逼的代码&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>单行代码</p><p><code>create database hero;</code></p><p>代码块</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">  echo <span class="string">&quot;这是一句非常牛逼的代码&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h1 id="十、数字处理："><a href="#十、数字处理：" class="headerlink" title="十、数字处理："></a>十、数字处理：</h1><p><strong>上标和下标：</strong></p><ol><li>Markdown语法</li></ol><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>上标｜$x^2$: x^2^</td><td></td></tr><tr><td>下标｜$x_2$: x<del>2</del></td><td></td></tr></tbody></table><ol start="2"><li>使用LaTex</li></ol><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>上标｜$x^2$ : <code>$x^2$</code></td><td></td><td></td></tr><tr><td>下标｜$x_2$ : <code>$x_2x$</code></td><td></td><td></td></tr></tbody></table><ol start="3"><li>html 语法：</li></ol><p><strong>代码：</strong></p><p><code>C&lt;sub&gt;n-1&lt;/sub&gt;&lt;sup style=&quot;margin-left:-20px&quot;&gt;m+n-2&lt;/sup&gt;</code>  </p><p><strong>效果：</strong></p><p>C<sub>n-1</sub><sup style="margin-left:-20px">m+n-2</sup></p><p>单个<code>$</code>之间则可以嵌入文本当中，套两层$可实现公式居中。<br>如果要复合标，可使用 <code>&#123;&#125;</code>，如 $x^{C_2}$ : <code>$x^&#123;C_2&#125;$</code> </p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
