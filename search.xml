<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>下一个更大元素 I</title>
      <link href="/2022/10/28/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I/"/>
      <url>/2022/10/28/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I/</url>
      
        <content type="html"><![CDATA[<p><code>nums1</code> 中数字 <code>x</code> 的 下一个更大元素 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 右侧 的 第一个 比 <code>x</code> 大的元素。</p><p>给你两个 没有重复元素 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从<code>0</code> 开始计数，其中 <code>nums1</code> 是 <code>nums2</code> 的子集。</p><p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p><p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 下一个更大元素 。</p><span id="more"></span><p>示例 1：</p><pre><code>输入：nums1 = [4,1,2], nums2 = [1,3,4,2].输出：[-1,3,-1]解释：nums1 中每个值的下一个更大元素如下所述：- 4 ，在nums2 的第三个位子 右边不存在下一个更大元素，所以答案是 -1 。- 1 ，在nums2 的第一个位子 下一个更大元素是 3 。- 2 ，在nums2 的第四个位子 不存在下一个更大元素，所以答案是 -1 。</code></pre><p>示例 2：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="symbol">nums1</span> = [<span class="number">2</span>,<span class="number">4</span>], <span class="symbol">nums2</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">-1</span>]</span><br><span class="line">解释：<span class="symbol">nums1</span> 中每个值的下一个更大元素如下所述：</span><br><span class="line">- <span class="number">2</span> ，在<span class="symbol">nums2</span> 的第二个位子 下一个更大元素是 <span class="number">3</span> 。</span><br><span class="line">- <span class="number">4</span> ，在<span class="symbol">nums2</span> 的第四个位子 不存在下一个更大元素，所以答案是 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure><h2 id="思路：单调栈-哈希表"><a href="#思路：单调栈-哈希表" class="headerlink" title="思路：单调栈 + 哈希表"></a>思路：单调栈 + 哈希表</h2><p>暴力解题就不搞了 n^2 ，谁都会，现在我们得降低时间复杂度。</p><p>单调栈，听名字就知道，这个栈保存的数据全是单调递增或递减的。</p><p>那怎么做出这种栈呢？即当一个元素想要加入前，与栈顶元素相比，比这个元素小的全部移除。</p><p>我们从后往前遍历 <code>nums2</code> 这个数组，将每个元素加入栈中。(加入时，已经把比元素大的移除了)</p><ul><li>若加入时，这个栈是空的，则说明这个元素在 <code>nums2</code> 数组的右侧没有比他更大的元素。在 哈希表 中记录为 <code>-1</code>；</li><li>若加入时，这个栈不空，则说明这个元素在 <code>nums2</code> 数组的右侧有比他更大的元素。在 哈希表 中记录为栈顶元素的大小；</li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>int* nextGreaterElement(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize)&#123;    *returnSize = nums1Size;    int *ans = malloc (nums1Size*sizeof(int));    int *stack = malloc (nums2Size*sizeof(int));    int top = 0;//定义栈。    int hash[10001];    memset (hash,-1,sizeof(hash));    for (int i = nums2Size - 1;i &gt;= 0;i--)&#123;        //移除栈顶比该元素小的元素。        while (top != 0 &amp;&amp; nums2[i] &gt; stack[top-1])            top--;        if (top != 0)            hash[nums2[i]] = stack[top-1];        //将元素加入栈中。        stack[top++] = nums2[i];    &#125;    for(int i = 0;i &lt; nums1Size;i++)&#123;        ans[i] = hash[nums1[i]];    &#125;    return ans;&#125;</code></pre><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (m * n)</code>。 m,n 分别为 nums1 和 nums2 的长度。</li><li>空间复杂度：<code>O (m + n)</code>。 栈的大小以及哈希表所占空间，因为c语言没有哈希表这个数据结构，所以哈希表的申请空间有点奇怪。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子数组的最小值之和</title>
      <link href="/2022/10/28/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C/"/>
      <url>/2022/10/28/%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数数组 <code>arr</code>，找到 <code>min(b)</code> 的总和，其中 <code>b</code> 的范围为 <code>arr</code> 的每个（连续）子数组。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = <span class="comment">[3,1,2,4]</span></span><br><span class="line">输出：17</span><br><span class="line">解释：</span><br><span class="line">子数组为 <span class="comment">[3]</span>，<span class="comment">[1]</span>，<span class="comment">[2]</span>，<span class="comment">[4]</span>，<span class="comment">[3,1]</span>，<span class="comment">[1,2]</span>，<span class="comment">[2,4]</span>，<span class="comment">[3,1,2]</span>，<span class="comment">[1,2,4]</span>，<span class="comment">[3,1,2,4]</span>。 </span><br><span class="line">最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = <span class="string">[11,81,94,43,3]</span></span><br><span class="line">输出：<span class="number">444</span></span><br></pre></td></tr></table></figure><p>提示：</p><p><code>1 &lt;= arr.length &lt;= 3 * 104</code><br><code>1 &lt;= arr[i] &lt;= 3 * 104</code></p><h2 id="思路一：暴力"><a href="#思路一：暴力" class="headerlink" title="思路一：暴力"></a>思路一：暴力</h2><p>计算出每个子数组的最小值进行相加<br>先计算长度为1的保存至数组SubarrayMin中，每次增加一个长度，i即为此时子数组长度。遍历，所有值相加。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="built_in">min</span>(a,b) (a &gt; b ? b : a)</span><br><span class="line"><span class="built_in">int</span> sumSubarrayMins(<span class="built_in">int</span>* arr, <span class="built_in">int</span> arrSize)&#123;</span><br><span class="line">    <span class="built_in">int</span> SubarrayMin[arrSize];</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arrSize;i++)&#123;</span><br><span class="line">        SubarrayMin[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arrSize;i++)&#123;</span><br><span class="line">        for(<span class="built_in">int</span> j = <span class="number">0</span>; i + j &lt; arrSize;j++)&#123;</span><br><span class="line">            SubarrayMin[j] = <span class="built_in">min</span>(SubarrayMin[ j ],arr[j + i]);</span><br><span class="line">            <span class="built_in">sum</span> += SubarrayMin[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n ^ 2)</code>。 </li><li>空间复杂度：<code>O (n)</code> 。</li></ul><h2 id="思路二：单调栈"><a href="#思路二：单调栈" class="headerlink" title="思路二：单调栈"></a>思路二：单调栈</h2><p>关于【<a href="">单调栈</a>】可以参考 <a href="./%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I.md">下一个最大元素｜题解</a></p><p>暴力解题的思路就是找到所有的子数组中的最小值，然后进行相加。</p><p>那么我们这就换一种思路，找到数组中的每一个元素可以在多少个子数组中充当最小值。把这个子数组的个数求出，乘以他的值，累加，即可求解。</p><p>我们先看元素 <code>arr[i]</code>，是不是只需要分别找到他的左边第一个比他大的值（下标 <code>i</code> ），和右边第一个比他大的值（下标 <code>j</code>），在下标 <code>[i,j]</code> 之间的子数组，只要 <code>arr[i]</code> 在这里面是不是就是最小的？</p><p>接下来就是找 <code>i</code> 和 <code>j</code> 了：</p><ul><li>创建单调递增栈，先从前往后遍历，将数组元素的下标（x）保存至栈中，在元素进去前，将比他大的元素移除，直到栈中所有元素都不比他大，则此时栈顶元素就是要找的 <code>i</code>,我们将 <code>x - i</code>保存至数组 <code>left[x]</code> 中。</li><li>再将栈重置，从后往前遍历，将数组元素的下标（x）保存至栈中，在元素进去前，，为了避免多算以及少算，将不小于他的元素移除，直到栈中所有元素都小于他，就能找到 <code>j</code> 我们将 <code>j - x</code> 保存至数组 <code>right[x]</code> 中。</li><li>那么下标为 <code>x</code> 的元素所在的子数组就共有 <code>left[x] * right[x]</code> 个。</li></ul><p>个数乘以元素，加入到sum中即可。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumSubarrayMins</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> arrSize)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> left[arrSize],right[arrSize];</span><br><span class="line">    <span class="type">int</span> stack[arrSize],top = <span class="number">0</span>;<span class="comment">//构建单调递减栈，栈中记录数据所在数据的下标</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrSize;i++)&#123;</span><br><span class="line">        <span class="comment">//移除比该元素大的数</span></span><br><span class="line">        <span class="keyword">while</span> (top != <span class="number">0</span> &amp;&amp; arr[i] &lt;= arr[stack[top<span class="number">-1</span>]])</span><br><span class="line">            top--;</span><br><span class="line">        <span class="keyword">if</span> (top != <span class="number">0</span>)</span><br><span class="line">            left[i] = i - stack[top <span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            left[i] = i + <span class="number">1</span>; </span><br><span class="line">        <span class="comment">//将元素下标加入栈中</span></span><br><span class="line">        stack[top++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    top = <span class="number">0</span>;<span class="comment">//初始化栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = arrSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span> (top != <span class="number">0</span> &amp;&amp; arr[i] &lt; arr[stack[top<span class="number">-1</span>]])</span><br><span class="line">            top--;</span><br><span class="line">        <span class="keyword">if</span> (top != <span class="number">0</span>)</span><br><span class="line">            right[i] = stack[top<span class="number">-1</span>] - i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right[i] = arrSize - i;</span><br><span class="line">        stack[top++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; arrSize;i++ )&#123;</span><br><span class="line">        sum += arr[i] * left[i] * right[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。遍历三次数组 </li><li>空间复杂度：<code>O (n)</code>。栈，left数组，right数组。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>和至少为 K 的最短子数组</title>
      <link href="/2022/10/26/%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BA-K-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2022/10/26/%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BA-K-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，找出 <code>nums</code> 中和至少为 <code>k</code> 的 <strong>最短非空子数组</strong> ，并返回该子数组的长度。如果不存在这样的 <strong>子数组</strong> ，返回 <code>-1</code> 。</p><p><strong>子数组</strong> 是数组中 <strong>连续</strong> 的一部分。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1], k = 1</span></span><br><span class="line"><span class="string">输出：1</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1,2], k = 4</span></span><br><span class="line"><span class="string">输出：-1</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [2,-1,2], k = 3</span></span><br><span class="line"><span class="string">输出：3</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li><li><code>1 &lt;= k &lt;= 109</code></li></ul><h2 id="思路一：暴力"><a href="#思路一：暴力" class="headerlink" title="思路一：暴力"></a>思路一：暴力</h2><p>暴力解题，没什么好说的，但存在着问题。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> shortestSubarray(<span class="built_in">int</span>* nums, <span class="built_in">int</span> numsSize, <span class="built_in">int</span> k)&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">min</span> = numsSize + <span class="number">1</span>;</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; numsSize;i++)&#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>,j;</span><br><span class="line">        for(j = i;<span class="built_in">sum</span> &lt; k &amp;&amp; j &lt; numsSize;j++)&#123;</span><br><span class="line">            <span class="built_in">sum</span> += nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sum</span> &gt;= k)&#123;</span><br><span class="line">            <span class="built_in">min</span> = <span class="built_in">min</span> &lt; (j - i) ? <span class="built_in">min</span> : (j - i); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">min</span> == numsSize + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n^2)</code>。在这种时间复杂度下，他的运行时间有可能超时，所以该方法不可取。</li><li>空间复杂度：<code>O (1)</code>。</li></ul><h2 id="思路二：前缀和-单调队列"><a href="#思路二：前缀和-单调队列" class="headerlink" title="思路二：前缀和 + 单调队列"></a>思路二：前缀和 + 单调队列</h2><p>创建一个数组 <code>preSumArr</code> 用来保存 <code>nums</code> 数组的前缀和。<br>然后使用前缀和的差来计算 子数组 的和，对应的长度就是两个前缀和的下标差。</p><p>那么怎么减少运算量呢？</p><p>需要理清下面两点(<code>a</code> &#x3D; <code>preSumArr[i+m]</code>,<code>b</code> &#x3D; <code>preSumArr[i]</code>)：</p><ul><li>当出现 <code>a - b &gt;= k</code> 时，是不是 <code>a</code> 后面的数据就不用和 <code>b</code> 数据进行比较了，因为无论怎么比他们的子数组都比 <code>m</code> 大。所以，<code>i</code> 位置的数据就用不着了。 </li><li>当 <code>a</code> 与 <code>b</code> 之间存在着一个数 <code>c</code> 比 <code>b</code> 小。那么如果 <code>a - b &gt;= k</code> 成立，那么一定会有 <code>a - c &gt;= k</code> 成立，子数组的长度是不是比 <code>m</code> 小？所以当出现了这么个数 <code>c</code> 时，<code>i</code> 位置的数据就用不着了 。</li></ul><p>根据以上2点可以创建一个队列 <code>queue</code> 用来增、删前缀和数组的元素，只记录下标。</p><p>拿出数组 <code>preSumArr</code> 的元素，和队列最前的元素相比较。</p><p>若差大于等于 <code>k</code> ，则删除队列中的该元素，直到队列中所有的数与其差值都小于 <code>k</code>。</p><p>此时再将数组元素加入至队列中，并将队列中比其大的元素删除。</p><blockquote><p>此时思考一点，我们每次将数组元素加入队列前，都把比他大的元素删除，那么这个队列从始至终不都是一个递增排列的吗？</p></blockquote><p>所以删除元素都很简单，只需要移动队列的前后指针即可。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> min(a,b) (a &lt; b ? a : b);</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shortestSubarray</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = numsSize + <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> preSumArr[numsSize+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> queue[numsSize+<span class="number">1</span>],front = <span class="number">0</span>,rear = <span class="number">0</span>;</span><br><span class="line">    preSumArr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算数组sums的前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; numsSize;i++)&#123;</span><br><span class="line">        preSumArr[i+<span class="number">1</span>] = preSumArr[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= numsSize;i++)&#123;</span><br><span class="line">        <span class="type">long</span> n = preSumArr[i];</span><br><span class="line">        <span class="comment">//删除队列的元素</span></span><br><span class="line">        <span class="keyword">while</span> ( rear != front &amp;&amp; n - preSumArr[queue[front]] &gt;= k)&#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans,i - queue[front]);</span><br><span class="line">            front++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除队列中比 n 大的数</span></span><br><span class="line">        <span class="keyword">while</span> ( rear != front &amp;&amp; n &lt;= preSumArr[queue[rear<span class="number">-1</span>]])&#123;</span><br><span class="line">            rear--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数加入队列</span></span><br><span class="line">        queue[rear] = i;</span><br><span class="line">        rear ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans &gt; numsSize ? <span class="number">-1</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。</li><li>空间复杂度：<code>O (n)</code>。申请了两个长度为n的数组</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短的桥</title>
      <link href="/2022/10/25/%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5/"/>
      <url>/2022/10/25/%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5/</url>
      
        <content type="html"><![CDATA[<p>给你一个大小为 <code>n * n</code> 的二元矩阵 <code>grid</code> ，其中 <code>1</code> 表示陆地，<code>0</code> 表示水域。</p><p>岛是由一片为的 <code>1</code> 形成的一个最大组，即不会与非组内的任何其他 <code>1</code> 相连。<code>grid</code> 中 恰好存在两座岛 。</p><p>你可以将任意数量的 <code>0</code> 变为 <code>1</code> ，以使两座岛连接起来，变成 一座岛 。</p><p>返回必须翻转的 <code>0</code> 的最小数目。</p><p> <span id="more"></span></p><p>示例 1：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="string">[[0,1],[1,0]]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="string">[[0,1,0],[0,0,0],[0,0,1]]</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="comment">[<span class="comment">[1,1,1,1,1]</span>,<span class="comment">[1,0,0,0,1]</span>,<span class="comment">[1,0,1,0,1]</span>,<span class="comment">[1,0,0,0,1]</span>,<span class="comment">[1,1,1,1,1]</span>]</span></span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h2 id="思路一：广度优先搜索"><a href="#思路一：广度优先搜索" class="headerlink" title="思路一：广度优先搜索"></a>思路一：广度优先搜索</h2><p>题目中求最少的翻转 <code>0</code> 的数目等价于求矩阵中两个岛的最短距离，因此我们可以广度优先搜索来找到矩阵中两个块的最短距离。首先找到其中一座岛，然后将其不断向外延伸一圈，直到到达了另一座岛，延伸的圈数即为最短距离。广度优先搜索时，我们可以将已经遍历过的位置标记为 <code>−1</code>，实际计算过程如下：</p><ul><li>我们通过遍历找到数组 <code>grid</code> 中的 <code>1</code> 后进行广度优先搜索，此时可以得到第一座岛的位置集合，记为 <code>island</code> ，并将其位置全部标记为 <code>−1</code>。</li><li>随后我们从 <code>island</code> 中的所有位置开始进行广度优先搜索，当它们到达了任意的 <code>1</code> 时，即表示搜索到了第二个岛，搜索的层数就是答案。</li></ul><p>别看代码长，其实很容易理解。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> shortestBridge(<span class="built_in">int</span>** grid, <span class="built_in">int</span> gridSize, <span class="built_in">int</span>* gridColSize) &#123;</span><br><span class="line">    <span class="built_in">int</span> n = gridSize;</span><br><span class="line">    <span class="built_in">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//构造一个 island 和队列 queue，island记录第一块岛。</span></span><br><span class="line">    <span class="built_in">int</span> *island = (<span class="built_in">int</span> *)malloc(sizeof(<span class="built_in">int</span>) * n * n); </span><br><span class="line">    <span class="built_in">int</span> *queue = (<span class="built_in">int</span> *)malloc(sizeof(<span class="built_in">int</span>) * n * n);</span><br><span class="line">    <span class="built_in">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 队列记录第一次出现值为 1 的坐标 (i,j)</span></span><br><span class="line">                queue[tail++] = i * n + j;</span><br><span class="line">                grid[i][j] = <span class="number">-1</span>;</span><br><span class="line">                <span class="built_in">int</span> islandSize = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">                    <span class="comment">// (x,y) 即是记录的 (i,j)</span></span><br><span class="line">                    <span class="built_in">int</span> x = queue[head] / n;</span><br><span class="line">                    <span class="built_in">int</span> y = queue[head] % n;</span><br><span class="line">                    island[islandSize++] = queue[head];</span><br><span class="line">                    head++;</span><br><span class="line">                    <span class="comment">//搜索值为 1 周围 4 个方块是否有 1， 如果有则将值为 1 的坐标添加到队列 queue</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="built_in">int</span> nx = x + dirs[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="built_in">int</span> ny = y + dirs[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="comment">// 考虑边界问题，判断坐标(x,y)的周围4个坐标是否出界</span></span><br><span class="line">                        <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] == <span class="number">1</span>) &#123;</span><br><span class="line">                            queue[tail++] = nx * n + ny;</span><br><span class="line">                            grid[nx][ny] = <span class="number">-1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//刚已经把 所有值为 1 的坐标全部记录进数组 island 中，并且把值修改为 -1；</span></span><br><span class="line">                <span class="comment">//现在要将其中一块岛屿 island 中所有坐标加载到队列中，</span></span><br><span class="line">                head = tail = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; islandSize; i++) &#123;</span><br><span class="line">                    queue[tail++] = island[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">int</span> step = <span class="number">0</span>;<span class="comment">//step记录需要翻转 0 的个数。</span></span><br><span class="line">                <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">                    <span class="comment">//接下来就是将 值为 -1 的坐标周围一圈的 0 全翻转为 -1。sz 为队列长度</span></span><br><span class="line">                    <span class="built_in">int</span> sz = tail - head;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                        <span class="built_in">int</span> x = queue[head] / n;</span><br><span class="line">                        <span class="built_in">int</span> y = queue[head] % n;</span><br><span class="line">                        head++;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                            <span class="built_in">int</span> nx = x + dirs[k][<span class="number">0</span>];</span><br><span class="line">                            <span class="built_in">int</span> ny = y + dirs[k][<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n) &#123;</span><br><span class="line">                                <span class="comment">//开始翻转 0 ；</span></span><br><span class="line">                                <span class="keyword">if</span> (grid[nx][ny] == <span class="number">0</span>) &#123;</span><br><span class="line">                                    queue[tail++] = nx * n + ny;</span><br><span class="line">                                    grid[nx][ny] = <span class="number">-1</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[nx][ny] == <span class="number">1</span>) &#123;</span><br><span class="line">                                    <span class="comment">//如果在这片区域搜寻到 1 则说明已经翻转完成</span></span><br><span class="line">                                    free(queue);</span><br><span class="line">                                    free(island);</span><br><span class="line">                                    <span class="keyword">return</span> step;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    step++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O(n^2)</code></li></ul><h2 id="思路二：深度优先搜索-广度优先搜索"><a href="#思路二：深度优先搜索-广度优先搜索" class="headerlink" title="思路二：深度优先搜索 + 广度优先搜索"></a>思路二：深度优先搜索 + 广度优先搜索</h2><p>解法思路与思路一类似，我们可以利用深度优先搜索求出其中的一座岛，然后利用广度优先搜索来找到两座岛的最短距离。深度度优先搜索时，我们可以将已经遍历过的位置标记为 <code>−1</code>，实际计算过程如下：</p><ul><li>我们通过遍历找到数组 <code>grid</code> 中的 <code>1</code> 后进行深度优先搜索，此时可以得到第一座岛的位置集合，记为 <code>island</code> ，并将其位置全部标记为 <code>−1</code>。</li><li>随后我们从 <code>island</code> 中的所有位置开始进行广度优先搜索，当它们到达了任意的 <code>1</code> 时，即表示搜索到了第二个岛，搜索的层数就是答案。</li></ul><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*该函数所表达的意思：</span></span><br><span class="line"><span class="comment">    坐标(x,y) 的值为 1 则加入至队列 queue 中，</span></span><br><span class="line"><span class="comment">    坐标(x,y) 周围与之相连的 1 也加入至队列 queue 中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">void</span> dfs(<span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="built_in">int</span>** grid, <span class="built_in">int</span> n, <span class="built_in">int</span> *queue, <span class="built_in">int</span> *tail) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= n || y &gt;= n || grid[x][y] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[(*tail)++] = x * n + y;</span><br><span class="line">    grid[x][y] = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//四个dfs函数对应了4个方向的坐标</span></span><br><span class="line">    dfs(x - <span class="number">1</span>, y, grid, n, queue, tail);</span><br><span class="line">    dfs(x + <span class="number">1</span>, y, grid, n, queue, tail);</span><br><span class="line">    dfs(x, y - <span class="number">1</span>, grid, n, queue, tail);</span><br><span class="line">    dfs(x, y + <span class="number">1</span>, grid, n, queue, tail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> shortestBridge(<span class="built_in">int</span>** grid, <span class="built_in">int</span> gridSize, <span class="built_in">int</span>* gridColSize) &#123;</span><br><span class="line">    <span class="built_in">int</span> n = gridSize;</span><br><span class="line">    <span class="built_in">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">int</span> *queue = (<span class="built_in">int</span> *)malloc(sizeof(<span class="built_in">int</span>) * n * n);</span><br><span class="line">                <span class="built_in">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">                dfs(i, j, grid, n, queue, &amp;tail);</span><br><span class="line">                <span class="built_in">int</span> step = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//此时队列 queue 已经将其中一块岛的所有坐标保存下来了。</span></span><br><span class="line">                <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">                    <span class="built_in">int</span> sz = tail - head;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                        <span class="built_in">int</span> x = queue[head] / n;</span><br><span class="line">                        <span class="built_in">int</span> y = queue[head] % n;</span><br><span class="line">                        head++;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                            <span class="built_in">int</span> nx = x + dirs[k][<span class="number">0</span>];</span><br><span class="line">                            <span class="built_in">int</span> ny = y + dirs[k][<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (grid[nx][ny] == <span class="number">0</span>) &#123;</span><br><span class="line">                                    queue[tail++] = nx * n + ny;</span><br><span class="line">                                    grid[nx][ny] = <span class="number">-1</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[nx][ny] == <span class="number">1</span>) &#123;</span><br><span class="line">                                    free(queue);</span><br><span class="line">                                    <span class="keyword">return</span> step;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    step++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(n^2)</code></li><li>空间复杂度：<code>O(n^2)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 广度优先搜索 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复字符的最长子串</title>
      <link href="/2022/10/24/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2022/10/24/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 最长子串 的长度。</p><span id="more"></span><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="section">输出: 3 </span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;bbbbb&quot;</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;pwwkew&quot;</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p>提示：</p><p><code>0 &lt;= s.length &lt;=  5 * 104</code><br><code>s</code> 由英文字母、数字、符号和空格组成</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题主要用到思路是：滑动窗口</p><p>什么是滑动窗口？</p><p>其实就是一个队列,比如例题中的 <code>abcabcbb</code> ，进入这个队列（窗口）为 <code>abc</code> 满足题目要求，当再进入 <code>a</code>，队列变成了 <code>abca</code>，这时候不满足要求。所以，我们要移动这个队列！</p><p>如何移动？</p><p>如何才能高效地移动这个队列，使得这个队列一直满足要求呢？那就得用到哈希表。<br>创建哈希表 <code>hash</code> 记录搜索的每一个字符最后出现的位置，每当出现一个字符，就将他的位置记录下来 <code>hash[s[rear]] = rear + 1</code> ，当队列进入一个字符时，使得队列中有两个字符相同时，我们就可以利用 <code>hash</code> 表快速的将左边那个字符移出去。</p><p>一直维持这样的队列，找出队列出现最长的长度时候，即可求出解！</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="type">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hash[<span class="number">127</span>] = &#123;<span class="number">0</span>&#125;,max = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>,rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[rear])&#123;</span><br><span class="line">        <span class="comment">//当在对列front下标的右侧出现2个相同的字符时，移动front。</span></span><br><span class="line">        <span class="keyword">if</span>(front &lt; hash[s[rear]])</span><br><span class="line">            front = hash[s[rear]];</span><br><span class="line">        max = max &gt; rear + <span class="number">1</span> - front ? max : rear + <span class="number">1</span> - front;</span><br><span class="line">        hash[s[rear]] = rear + <span class="number">1</span>;</span><br><span class="line">        rear++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。n为字符串长度</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同路径II</title>
      <link href="/2022/10/23/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/"/>
      <url>/2022/10/23/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</url>
      
        <content type="html"><![CDATA[<p>一个机器人位于一个 <code>m * n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><span id="more"></span><p><strong>示例 1：</strong><br><img src="/./../img/robot1.jpg"></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">3</span>x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 <span class="number">2</span> 条不同的路径：</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong><br><img src="/./../img/robot2.jpg"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid = <span class="string">[[0,1],[0,0]]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><p>不同路径II 可以用<a href="./%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.md">不同路径</a>的动态规划代码完成，不过要让有障碍物的位置 <code>f[i][j]</code> 应该为 <code>0</code>。</p><p>现在还有一种叫做滚动数组，也就是说，这个数组 <code>f</code> 是在滚动的<br><br/><br>什么意思呢？就是说 <code>i = 0</code> 时的数组和 <code>i = 1</code> 时的数组表达的东西不一样，<code>i</code> 的值就代表了这个数组表示的是第 <code>i</code> 行对应的数组。</p><blockquote><p><code>f[j] = f[j - 1] + f[j]</code></p></blockquote><blockquote><p><code>f(i,j) = f(i−1,j) + f(i,j−1)</code></p></blockquote><p>两者是等价的。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int uniquePathsWithObstacles(int** obstacleGrid, int obstacleGridSize, int* obstacleGridColSize)&#123;</span><br><span class="line">    int n = obstacleGridSize, m = obstacleGridColSize<span class="comment">[0]</span>;</span><br><span class="line">    int f<span class="comment">[m]</span>;</span><br><span class="line">    memset(f, 0, sizeof(f));</span><br><span class="line">    f<span class="comment">[0]</span> = (obstacleGrid<span class="comment">[0]</span><span class="comment">[0]</span> == 0);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">            if (obstacleGrid<span class="comment">[i]</span><span class="comment">[j]</span> == 1) &#123;</span><br><span class="line">                f<span class="comment">[j]</span> = 0;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (j - 1 &gt;= 0 &amp;&amp; obstacleGrid<span class="comment">[i]</span><span class="comment">[j - 1]</span> == 0) &#123;</span><br><span class="line">                f<span class="comment">[j]</span> += f<span class="comment">[j - 1]</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f<span class="comment">[m - 1]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (m * n)</code>。</li><li>空间复杂度：<code>O (m)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同路径</title>
      <link href="/2022/10/23/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
      <url>/2022/10/23/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p>一个机器人位于一个 <code>m * n</code> 网格的左上角（起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="/./../img/robot_maze.png"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, <span class="built_in">n</span> = <span class="number">7</span></span><br><span class="line">输出：<span class="number">28</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 <span class="number">3</span> 条路径可以到达右下角。</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line"><span class="number">3.</span> 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">7</span>, <span class="built_in">n</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">28</span></span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, <span class="built_in">n</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="解题思路-一-：动态规划"><a href="#解题思路-一-：动态规划" class="headerlink" title="解题思路(一)：动态规划"></a>解题思路(一)：动态规划</h2><p>用二维数组<code>f(i, j)</code> 表示从左上角走到 <code>(i, j)</code> 的路径数量。</p><p>由于我们每一步只能从向下或者向右移动一步，因此要想走到 <code>(i, j)</code>，如果向下走一步，那么会从 <code>(i-1, j)</code> 走过来；如果向右走一步，那么会从 <code>(i, j-1)</code> 走过来。因此我们可以写出动态规划转移方程：</p><blockquote><p><code>f(i,j) = f(i−1,j) + f(i,j−1)</code></p></blockquote><p>但是由于第一行与第一列在边界，所以只能为 <code>1</code> 。</p><p>简单的来说就像是个杨辉三角。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int uniquePaths(int m, int n) &#123;</span><br><span class="line">    int f<span class="comment">[m]</span><span class="comment">[n]</span>;</span><br><span class="line">    f<span class="comment">[0]</span><span class="comment">[0]</span> = 1;</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            if(i = 0 &amp;&amp; j &gt; 0)&#123;</span><br><span class="line">                f<span class="comment">[0]</span><span class="comment">[j]</span> = f<span class="comment">[0]</span><span class="comment">[j - 1]</span>;</span><br><span class="line">            &#125;else if(j = 0 &amp;&amp; i &gt; 0)&#123;</span><br><span class="line">                f<span class="comment">[i]</span><span class="comment">[0]</span> = f<span class="comment">[i - 1]</span><span class="comment">[0]</span>;</span><br><span class="line">            &#125;else if(i &gt; 0 &amp;&amp;j &gt; 0)&#123;</span><br><span class="line">                f<span class="comment">[i]</span><span class="comment">[j]</span> = f<span class="comment">[i - 1]</span><span class="comment">[j]</span> + f<span class="comment">[i]</span><span class="comment">[j - 1]</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f<span class="comment">[m - 1]</span><span class="comment">[n - 1]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(m * n)</code></li><li>空间复杂度：<code>O(m * n)</code></li></ul><h2 id="解题思路-二-：排列组合原理"><a href="#解题思路-二-：排列组合原理" class="headerlink" title="解题思路(二)：排列组合原理"></a>解题思路(二)：排列组合原理</h2><p>这个机器人总共需要走 <code>m + n -2</code> 步走到终点。其中有 <code>m - 1</code> 步是向下走的， <code>n - 1</code> 步是向右走的。利用排列组合知识，可以得出总共需要走 C<sub>n-1</sub><sup style="margin-left:-20px">m+n-2</sup> 步，意思就是从 <code>m + n -2</code> 步中选择 <code>n - 1</code> 步向右其余向左。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> unique<span class="constructor">Paths(<span class="params">int</span> <span class="params">m</span>, <span class="params">int</span> <span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//保证n更小。</span></span><br><span class="line">    <span class="keyword">if</span> (m &lt; n)</span><br><span class="line">        return unique<span class="constructor">Paths(<span class="params">n</span> , <span class="params">m</span>)</span>;</span><br><span class="line">    <span class="comment">//计算路径条数</span></span><br><span class="line">    <span class="built_in">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        ans = ans<span class="operator"> * </span>(m + i - <span class="number">1</span>)<span class="operator"> / </span>i; </span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(min(n,m))</code>;</li><li>空间复杂度：<code>O(1)</code>;</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串相乘</title>
      <link href="/2022/10/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
      <url>/2022/10/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
      
        <content type="html"><![CDATA[<p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p><span id="more"></span><p>注意：不能使用任何内置的 <code>BigInteger</code> 库或直接将输入转换为整数。</p><p>示例 1:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="symbol">num1</span> = <span class="string">&quot;2&quot;</span>, <span class="symbol">num2</span> = <span class="string">&quot;3&quot;</span></span><br><span class="line">输出: <span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="symbol">num1</span> = <span class="string">&quot;123&quot;</span>, <span class="symbol">num2</span> = <span class="string">&quot;456&quot;</span></span><br><span class="line">输出: <span class="string">&quot;56088&quot;</span></span><br></pre></td></tr></table></figure><p>提示：</p><p><code>1 &lt;= num1.length, num2.length &lt;= 200</code></p><p><code>num1</code> 和 <code>num2</code> 只能由数字组成。</p><p><code>num1</code> 和 <code>num2</code> 都不包含任何前导零，除了数字0本身。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>该算法是通过两数相乘时，乘数某位与被乘数某位相乘，与产生结果的位置的规律来完成。具体规律如下：</p><p>乘数 <code>num1</code> 位数为 <code>s1</code>，被乘数 <code>num2</code> 位数为 <code>s2</code>， <code>num1 x num2</code> 结果 <code>num3</code> 最大总位数为 <code>s1+s2</code><br><code>num1[i] x num2[j]</code> 的结果为 <code>value</code>(位数为两位，”0x”,”xy”的形式)，其第一位位于 <code>num3[i+j]</code>，第二位位于 <code>num3[i+j+1]</code>。</p><p>结合下图更容易理解:</p><p><img src="/./../img/171cad48cd0c14f565f2a0e5aa5ccb130e4562906ee10a84289f12e4460fe164-image.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">multiply</span><span class="params">(<span class="type">char</span> * num1, <span class="type">char</span> * num2)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s1 = <span class="built_in">strlen</span>(num1);</span><br><span class="line">    <span class="type">int</span> s2 = <span class="built_in">strlen</span>(num2);</span><br><span class="line">    <span class="type">char</span> *num3 = (<span class="type">char</span> *)<span class="built_in">malloc</span>((s1+s2+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="comment">//将num3全所有字符变为0，再在结尾加上&#x27;\0&#x27;;</span></span><br><span class="line">    <span class="built_in">memset</span>(num3,<span class="string">&#x27;0&#x27;</span>,s1 + s2 );</span><br><span class="line">    num3[s1 + s2] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//从后往前遍历，可以避免进位问题。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s1 - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = s2 - <span class="number">1</span>;j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="type">int</span> value = num3[i + j + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> + (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>) ;</span><br><span class="line">            num3[i + j] += value / <span class="number">10</span>;</span><br><span class="line">            num3[i + j + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span> + value % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分3种情况输出</span></span><br><span class="line">    <span class="keyword">if</span>(num3[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; num3[<span class="number">1</span>] &amp;&amp; num3[<span class="number">1</span>] != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//首位为0，但结果不为0，直接舍去第一个字符</span></span><br><span class="line">        <span class="keyword">return</span> num3 + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num3[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//结果为0输出0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//直接输出num3</span></span><br><span class="line">        <span class="keyword">return</span> num3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (M * N)</code>。 M,N 分别为 num1 和 num2 的长度。</li><li>空间复杂度：<code>O (M + N)</code> 。 用于存储计算结果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缺失的第一个正数</title>
      <link href="/2022/10/19/%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
      <url>/2022/10/19/%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1,2,0]</span></span><br><span class="line"><span class="string">输出：3</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [3,4,-1,1]</span></span><br><span class="line"><span class="string">输出：2</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[7,8,9,11,12]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="思路：原地哈希表"><a href="#思路：原地哈希表" class="headerlink" title="思路：原地哈希表"></a>思路：原地哈希表</h2><br/><ul><li><p>要求时间复杂度为 <code>O(n)</code> ，很容易想到是把数组里面的所有正数放到哈希表中，再利用一次遍历即可找出缺失的最小正数。但是这样，空间复杂度就也变成了 <code>O(n)</code> 不符合题目所说的常数级了。<br>在这上面进行改进，把原有的数组空间看成一个哈希表，也就是原地哈希表。</p></li><li><p>那么，我们可以采取这样的思路：就把 <code>1</code> 这个数放到下标为 <code>0</code> 的位置， <code>2</code> 这个数放到下标为 <code>1</code> 的位置，按照这种思路整理一遍数组。然后我们再遍历一次数组，第 <code>1</code> 个遇到的它的值不等于下标的那个数，就是我们要找的缺失的第一个正数。</p></li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int firstMissingPositive(int* nums, int numsSize)&#123;</span><br><span class="line">    for(int i = 0 ; i &lt; numsSize;i++)&#123;</span><br><span class="line">        while (nums<span class="comment">[i]</span> != i + 1)&#123;</span><br><span class="line">            if (nums<span class="comment">[i]</span> &lt;= 0 || nums<span class="comment">[i]</span> &gt; numsSize || nums<span class="comment">[i]</span> == nums<span class="comment">[nums<span class="comment">[i]</span> - 1]</span>)</span><br><span class="line">                break;</span><br><span class="line">            // 将nums<span class="comment">[i]</span> 放置到对应位置上<span class="comment">[1,2,3...]</span></span><br><span class="line">            int idx = nums<span class="comment">[i]</span> - 1;</span><br><span class="line">            nums<span class="comment">[i]</span> = nums<span class="comment">[idx]</span>;</span><br><span class="line">            nums<span class="comment">[idx]</span> = idx + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; numsSize ;i++) &#123;</span><br><span class="line">        if (nums<span class="comment">[i]</span> != (i + 1)) &#123;</span><br><span class="line">            return (i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return numsSize + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。遍历了整个数组一遍。</li><li>空间复杂度：<code>O (1)</code>。原地哈希表，没有申请额外的线性空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索旋转数组</title>
      <link href="/2022/10/18/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
      <url>/2022/10/18/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>整数数组 <code>nums</code> 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 <code>k（0 &lt;= k &lt; nums.length）</code>上进行了 旋转，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 <code>0</code> 开始 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>时间复杂度必须为 O(log n)。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[4,5,6,7,0,1,2]</span>, target = <span class="number">0</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[4,5,6,7,0,1,2]</span>, target = <span class="number">3</span></span><br><span class="line">输出：-<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>], <span class="keyword">target</span> = <span class="number">0</span></span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 中的每个值都 独一无二</li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h2 id="思路：二分法"><a href="#思路：二分法" class="headerlink" title="思路：二分法"></a>思路：二分法</h2><ul><li>二分查找</li></ul><p>对于我们来说更熟悉于查找 递增数组 <code>[0,1,2,4,5,6,7]</code> 中的值。</p><p>那么对于旋转后的数组 <code>[4,5,6,7,0,1,2]</code> 我们不太熟练。所以我们就把这个数组转化成我们熟知的问题，也就是把数组 <code>[4,5,6,7,0,1,2]</code> 重新旋转回去，那么怎么做呢？</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">4,5,6,7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"> ^ ^ ^ ^</span><br><span class="line">[<span class="number">4,5,6,7</span>,<span class="number">0,1,2,4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">               ^ ^ ^ ^</span><br></pre></td></tr></table></figure><p>把数组 <code>[4,5,6,7,0,1,2]</code> 看成循环数组:<br><code>[4,5,6,7,0,1,2,4,5,6,7,0,1,2,······]</code><br>然后取出最前面的有序数组 <code>[0,1,2,4,5,6,7]</code> ，进行二分查找。<br>找到最小元素 <code>0</code> 的下标 <code>i</code> ,作为最低位，则最高位为 <code>i - 1 + numsSize</code><br>可以利用循环数组的特性: <code>a[n] = a[n % numsSize]</code><br>可以不用重新申请空间做数组，最后进行代码实现。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> <span class="keyword">target</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; numsSize;i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[i<span class="number">-1</span>]) low = i;</span><br><span class="line">    <span class="keyword">int</span> high = low - <span class="number">1</span> + numsSize;</span><br><span class="line">    <span class="comment">//利用二分法查找元素 </span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid % numsSize] &lt; <span class="keyword">target</span>)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(nums[mid % numsSize] &gt; <span class="keyword">target</span>)</span></span>&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid % numsSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。主要是遍历用的时间多，二分使用的时间是log级别的，相比于线性可以忽略不计</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K 个一组翻转链表</title>
      <link href="/2022/10/17/K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/10/17/K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><span id="more"></span><p><strong>示例1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="string">[2,1,4,3,5]</span></span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">[3,2,1,4,5]</span></span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>先定义一个指针数组 <code>node[k]</code> ，用来记录前 <code>k</code> 个节点地址；再用 <code>nextHead</code>指针指向  <code>node[k-1]</code> 节点的下一个 <code>next</code> 节点，以便于使用递归。</p><ul><li><p>若不足 <code>k</code> 个节点，则直接返回 <code>head</code> </p></li><li><p>若足够 <code>k</code> 个节点，则进行下一步操作；</p></li></ul><p>从最后一个节点 <code>node[k-1]</code> 开始，每个节点的 <code>next</code> 都重新指向前一个节点.<br>除了这前 <code>k</code> 个节点外的链表重新看成一个新的 <code>nextHead</code> 链表。<br>前k个节点不是还有一个特殊的节点，头节点 <code>head</code> 么；<br>那么他的 <code>next</code> 指向的就是下一个链表的头节点 <code>reverseKGroup(nextHead,k)</code>，<br>这样就把前 <code>k</code> 个节点全部完成了翻转;</p><p>以此类推。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">struct ListNode* reverseKGroup(struct ListNode* head, int k)&#123;</span><br><span class="line">    struct ListNode *<span class="keyword">node</span><span class="title">[k</span>];</span><br><span class="line">    if ( head == NULL )&#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        <span class="keyword">node</span><span class="title">[0</span>] = head;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = <span class="number">1</span> ; i <span class="tag">&lt; k ; i++)&#123;//此处总共需要记录k - 1 个节点 </span></span><br><span class="line"><span class="tag">        node[i] = node[i-1]-&gt;</span>next; </span><br><span class="line">        //当需要记录的节点少于k个时，就直接返回头节点，不需要进行翻转。</span><br><span class="line">        if(<span class="keyword">node</span><span class="title">[i</span>] == NULL)</span><br><span class="line">            return head; </span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode *nextHead = <span class="keyword">node</span><span class="title">[k-1</span>]-&gt;next;</span><br><span class="line">    //接下来就是完成翻转的任务。</span><br><span class="line">    for (int i = k - <span class="number">1</span>;i &gt; <span class="number">0</span> ; i--)&#123;</span><br><span class="line">        <span class="keyword">node</span><span class="title">[i</span>]-&gt;next = <span class="keyword">node</span><span class="title">[i-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    //利用递归重复以上操作。</span><br><span class="line">    <span class="keyword">node</span><span class="title">[0</span>]-&gt;next = reverseKGroup(nextHead,k);</span><br><span class="line">    return <span class="keyword">node</span><span class="title">[k-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。链表长度</li><li>空间复杂度：<code>O (n)</code>。申请了储存各个节点的地址空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两两交换节点</title>
      <link href="/2022/10/16/%E2%80%9C%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E8%8A%82%E7%82%B9%E2%80%9D/"/>
      <url>/2022/10/16/%E2%80%9C%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E8%8A%82%E7%82%B9%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><span id="more"></span><p>（<a href="./K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.md" title="K 个一组翻转链表">那如果不是两两交换，有可能是前k个节点发生翻转呢？这样该怎么做？</a>）</p><p><strong>示例1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1,2,3,4</span>]</span><br><span class="line">输出：[<span class="number">2,1,4,3</span>]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p><strong>示例3:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[1]</span></span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>每2个节点为一组，先完成链表的前2个节点操作，后面每组的操作相同，将第一个节点 <code>node1</code> 和第二个节点 <code>node2</code> 发生交换，然后把第三个节点 <code>node3(node2-&gt;next)</code> 看成新的 <code>node1</code> 进行下一轮的操作。</p><p>时间复杂度：O(m + n)，m,n分别为两个链表的长度。</p><h3 id="递归代码："><a href="#递归代码：" class="headerlink" title="递归代码："></a>递归代码：</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* swapPairs(struct ListNode*<span class="built_in"> head</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">(head</span> == NULL ||<span class="built_in"> head</span>-&gt;<span class="keyword">next</span> == NULL) &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="built_in"> head</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode* node1 =<span class="built_in"> head</span>;</span><br><span class="line">    struct ListNode* node2 =<span class="built_in"> head</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">    node1-&gt;<span class="keyword">next</span> = swapPairs(node2-&gt;<span class="keyword">next</span>);</span><br><span class="line">    node2-&gt;<span class="keyword">next</span> =<span class="built_in"> head</span>;</span><br><span class="line">    <span class="keyword">return</span> node2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。</li><li>空间复杂度：<code>O (n)</code>。 每次使用递归都会申请两个节点空间，故空间复杂度：<code>O (n)</code>。</li></ul><h3 id="迭代代码："><a href="#迭代代码：" class="headerlink" title="迭代代码："></a>迭代代码：</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* swapPairs(struct ListNode* head) &#123;</span><br><span class="line">    struct ListNode dummyHead;</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line">    <span class="comment">//temp是指向头节点的那个指针</span></span><br><span class="line">    struct ListNode* temp = &amp;dummyHead;</span><br><span class="line">    <span class="comment">//当第一个节点和第二个节点不为空时。</span></span><br><span class="line">    <span class="function"><span class="title">while</span> (temp-&gt;</span><span class="function"><span class="title">next</span> != NULL &amp;&amp; temp-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next != NULL) &#123;</span><br><span class="line">        <span class="function"><span class="title">struct</span> ListNode* node1 = temp-&gt;</span>next;</span><br><span class="line">        <span class="function"><span class="title">struct</span> ListNode* node2 = temp-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next;</span><br><span class="line">        <span class="function"><span class="title">temp</span>-&gt;</span>next = node2; <span class="comment">//头节点改为第二个节点</span></span><br><span class="line">        <span class="function"><span class="title">node1</span>-&gt;</span><span class="function"><span class="title">next</span> = node2-&gt;</span>next;<span class="comment">//第一个节点的下个节点为第三个节点</span></span><br><span class="line">        <span class="function"><span class="title">node2</span>-&gt;</span>next = node1; <span class="comment">//第二个节点指向第一个节点</span></span><br><span class="line">        temp = node1; <span class="comment">//temp指向了第三个节点，将第三个节点当成第一个节点，重新开始新一轮循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    return dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并k个有序链表</title>
      <link href="/2022/10/15/%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/10/15/%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><h2 id="思路：递归"><a href="#思路：递归" class="headerlink" title="思路：递归"></a>思路：递归</h2><p>要解决 <code>k</code>个链表合成 的问题，就得先解决两个链表合成问题。</p><p><a href="./%E9%80%92%E5%BD%92%E4%BB%A5%E5%8F%8A%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8.md" title="合并两个链表">合并两个有序列表思路</a></p><p>已经知道两个链表怎么合成，接下来就是把每个链表两两合成。直到合成到一个链表为止。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line">    <span class="keyword">struct</span> ListNode *next;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">//合成两个链表的函数</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* merge<span class="constructor">TwoLists(<span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">l1</span>, <span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">l2</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* merge<span class="constructor">KLists(<span class="params">struct</span> ListNode<span class="operator">**</span> <span class="params">lists</span>, <span class="params">int</span> <span class="params">listsSize</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (listsSize<span class="operator"> == </span>NULL) <span class="comment">//排除0个链表合成</span></span><br><span class="line">        return NULL;</span><br><span class="line">    <span class="keyword">while</span> (listsSize &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//链表两两合成，直到合完为止。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; listsSize<span class="operator"> / </span><span class="number">2</span>;i++)&#123;</span><br><span class="line">            lists<span class="literal">[<span class="identifier">i</span>]</span> = merge<span class="constructor">TwoLists(<span class="params">lists</span>[<span class="params">i</span>] , <span class="params">lists</span>[<span class="params">listsSize</span> - <span class="params">i</span> - 1])</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        listsSize = ( listsSize + <span class="number">1</span> )<span class="operator"> / </span><span class="number">2</span>; <span class="comment">//合并完后还剩下的链表数量 </span></span><br><span class="line">    &#125;</span><br><span class="line">    return lists<span class="literal">[<span class="number">0</span>]</span>;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">//利用递归 完成两个链表的合并</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* merge<span class="constructor">TwoLists(<span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">l1</span>, <span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">l2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1<span class="operator"> == </span>NULL)&#123;</span><br><span class="line">        return l2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (l2<span class="operator"> == </span>NULL)&#123;</span><br><span class="line">        return l1;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (l1 -&gt; <span class="keyword">val</span> &lt; l2 -&gt; <span class="keyword">val</span> )&#123;</span><br><span class="line">        l1 -&gt; next = merge<span class="constructor">TwoLists(<span class="params">l1</span> -&gt; <span class="params">next</span> , <span class="params">l2</span>)</span>;</span><br><span class="line">        return l1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        l2 -&gt; next = merge<span class="constructor">TwoLists(<span class="params">l2</span> -&gt; <span class="params">next</span> , <span class="params">l1</span>)</span>;</span><br><span class="line">        return l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (kn*logk)</code>。每个元素遍历k次，使用二分思想将k个链表合并，相当于 kn*logk 。</li><li>空间复杂度：<code>O (logk)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并两个有序列表</title>
      <link href="/2022/10/15/%E9%80%92%E5%BD%92%E4%BB%A5%E5%8F%8A%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2022/10/15/%E9%80%92%E5%BD%92%E4%BB%A5%E5%8F%8A%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>将两个升序链表合并为一个新的 <code>升序</code> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><span id="more"></span><br/><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：list1 = <span class="comment">[1,2,4]</span>, list2 = <span class="comment">[1,3,4]</span></span><br><span class="line">输出：<span class="comment">[1,1,2,3,4,4]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：list1 = <span class="comment">[]</span>, list2 = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><h2 id="思路-一：递归"><a href="#思路-一：递归" class="headerlink" title="思路 一：递归"></a>思路 一：递归</h2><p>这个就是把所有值从小到大串起来；值更小的节点指向一个比他值更大的一个节点；</p><p>也就是说可以利用递归定义两个列表的操作：</p><blockquote><p>list1[0] + merge(list1[1],list2) list1[0] &lt; list2[0]</p><p>list2[0] + merge(list1,list2[1]) list1[0] &gt;&#x3D; list2[0]<br>​</p></blockquote><p>也就是说，两个链表头部值较小的一个节点与剩下元素的 <code>merge</code> 操作结果合并;</p><p>但也要注意排除空链表。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line">    <span class="keyword">struct</span> ListNode *next;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* merge<span class="constructor">TwoLists(<span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">list1</span>, <span class="params">struct</span> ListNode<span class="operator">*</span> <span class="params">list2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1<span class="operator"> == </span>NULL)&#123;</span><br><span class="line">        return list2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (list2<span class="operator"> == </span>NULL)&#123;</span><br><span class="line">        return list1;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (list1 -&gt; <span class="keyword">val</span> &lt; list2 -&gt; <span class="keyword">val</span> )&#123;</span><br><span class="line">        list1 -&gt; next = merge<span class="constructor">TwoLists(<span class="params">list1</span> -&gt; <span class="params">next</span> , <span class="params">list2</span>)</span>;</span><br><span class="line">        return list1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        list2 -&gt; next = merge<span class="constructor">TwoLists(<span class="params">list2</span> -&gt; <span class="params">next</span> , <span class="params">list1</span>)</span>;</span><br><span class="line">        return list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。</li><li>空间复杂度：<code>O (1)</code>。</li></ul><h2 id="思路-二：迭代"><a href="#思路-二：迭代" class="headerlink" title="思路 二：迭代"></a>思路 二：迭代</h2><p>我们也可以利用迭代来实现上面的算法。也就是说当list1 和list2 不为空时，只需要比较头节点的值的大小，小的那个节点添加到结果那里，当一个节点被添加，该链表的节点往后移一位。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    int val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *next;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>* <span class="title function_ invoke__">mergeTwoLists</span>(<span class="keyword">struct</span> <span class="title class_">ListNode</span>* list1, <span class="keyword">struct</span> <span class="title class_">ListNode</span>* list2)&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *prehead = (<span class="keyword">struct</span> <span class="title class_">ListNode</span>*)<span class="title function_ invoke__">malloc</span>(<span class="title function_ invoke__">sizeof</span>(<span class="keyword">struct</span> <span class="title class_">ListNode</span>));</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *prev = prehead;    </span><br><span class="line">    <span class="title function_ invoke__">while</span> (list1 != NULL &amp;&amp; list2 != NULL) &#123;</span><br><span class="line">        <span class="title function_ invoke__">if</span> (list1 <span class="punctuation">-&gt;</span> val &lt; list2 <span class="punctuation">-&gt;</span> val) &#123;</span><br><span class="line">            prev <span class="punctuation">-&gt;</span> next = list1;</span><br><span class="line">            list1 = list1 <span class="punctuation">-&gt;</span> next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev <span class="punctuation">-&gt;</span> next = list2;</span><br><span class="line">            list2 = list2 <span class="punctuation">-&gt;</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev <span class="punctuation">-&gt;</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">    prev <span class="punctuation">-&gt;</span> next = list1 == NULL ? list2 : list1;</span><br><span class="line">    <span class="keyword">return</span> prehead <span class="punctuation">-&gt;</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 迭代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器盛水</title>
      <link href="/2022/10/13/%E2%80%9C%E5%AE%B9%E5%99%A8%E7%9B%9B%E6%B0%B4%E2%80%9D/"/>
      <url>/2022/10/13/%E2%80%9C%E5%AE%B9%E5%99%A8%E7%9B%9B%E6%B0%B4%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。</p><span id="more"></span><p><strong>说明：</strong><br>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1,8,6,2</span>,<span class="number">5,4,8,3</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">49</span> </span><br><span class="line">解释：图中垂直线代表输入数组 [<span class="number">1,8,6,2</span>,<span class="number">5,4,8,3</span>,<span class="number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="number">49</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="思路一：暴力法"><a href="#思路一：暴力法" class="headerlink" title="思路一：暴力法"></a>思路一：暴力法</h2><p>遍历数组每个元素，并计算出该元素下标的数组所形成的最大储水量，并保存在另一个数组中。</p><p>易知面积公式 ： min (height[j],height[i]) * (i - j);</p><p>时间复杂度 O(n^2)</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) (a &gt; b ? a : b)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a,b) (a &lt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(<span class="type">int</span>* height, <span class="type">int</span> heightSize)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> visit[heightSize];</span><br><span class="line">    <span class="built_in">memset</span>( visit , <span class="number">0</span> ,<span class="built_in">sizeof</span> (visit));</span><br><span class="line">    <span class="type">int</span> Max = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; heightSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            visit[i] = <span class="built_in">max</span>( (i - j) * <span class="built_in">min</span>(height[i],height[j]) ,visit[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Max = <span class="built_in">max</span>(Max,visit[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="思路二：双指针"><a href="#思路二：双指针" class="headerlink" title="思路二：双指针"></a>思路二：双指针</h2><p>面积是一个矩形，长乘高，那么要求面积最大，先让长最大，长最大时得出一个面积，当宽增大时，看面积是否增大。</p><p>利用双指针，一个指向数组头 <code>head</code> ，一个指向数组尾部 <code>tail</code> ，让 <code>height[head]</code> 与 <code>height[tail]</code> 中值小的那个向往间靠。</p><p>时间复杂度为O(n);</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define max(a,b) (a &gt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> maxArea(<span class="type">int</span>* height, <span class="type">int</span> heightSize)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">head</span> = <span class="number">0</span>,<span class="built_in">tail</span> = heightSize - <span class="number">1</span>,MAX = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">head</span> &lt; <span class="built_in">tail</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[<span class="built_in">tail</span>] &lt; height[<span class="built_in">head</span>]) &#123;</span><br><span class="line">            <span class="comment">//当宽变化时，求出面积，然后与最大面积相比，如果更大，则替代</span></span><br><span class="line">            MAX = <span class="built_in">max</span>(MAX, height[<span class="built_in">tail</span>] * (<span class="built_in">tail</span> - <span class="built_in">head</span>));</span><br><span class="line">            <span class="built_in">tail</span> --;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            MAX = <span class="built_in">max</span>(MAX, height[<span class="built_in">head</span>] * (<span class="built_in">tail</span> - <span class="built_in">head</span>));</span><br><span class="line">            <span class="built_in">head</span> ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (n)</code>。</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找数组中的中位数</title>
      <link href="/2022/10/10/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2022/10/10/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong>。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[1,3]</span>, nums2 = <span class="comment">[2]</span></span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = <span class="comment">[1,2,3]</span> ，中位数 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="symbol">nums1</span> = [<span class="number">1</span>,<span class="number">2</span>], <span class="symbol">nums2</span> = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2.50000</span></span><br><span class="line">解释：合并数组 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] ，中位数 <span class="comment">(2 + 3)</span> / <span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>由于题目中要求时间复杂度为 <code>O(log (m+n))</code> 使用普通的遍历方法肯定是达不到要求的。要产生log的话一般是要使用二分法来解题。</p><br/><ul><li>二分法</li></ul><p>把两个数组的所有数据平均分成两个数组，用两个板隔开，两个板的左边一个，右边为一个。<br>两个板的位置分别记为 <code>array1</code> 和 <code>array2</code> 那么要找到中位数，只需要保证<br>第一块板左边最大的数 小于 第二块板右边最小的数 即 <code>Lmax1 &lt; Rmin2</code> 和<br>第二块板左边最大的数 小于 第一块板右边最小的数 即 <code>Lmax2 &lt; Rmin1</code> 。</p><p>那么现在就是两块板放置的问题，我们一开始把两个板放在两个数组的最中间，<br>当 <code>Lmax1 &gt; Rmin2</code>时，第一块板往左移，使 <code>Lmax1</code> 变小。同理 当 <code>Lmax2 &gt; Rmin1</code> 时，第一块板往右移，使 <code>Rmin1</code> 变小。<br>因为要保证板两边的数量相同，那么第一块板向左移多少，第二块板就得往反方向移多少，<br>即 <code>array1 + array2 = m + n</code> 。<br>移动板，直到满足 <code>Lmax1 &lt; Rmin2 &amp;&amp; Lmax2 &lt; Rmin1</code> 。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#define max(a,b) (a &gt; b ? a : b)</span><br><span class="line">#define min(a,b) (a &lt; b ? a : b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> findMedianSortedArrays(<span class="built_in">int</span>* nums1, <span class="built_in">int</span> nums1Size, <span class="built_in">int</span>* nums2, <span class="built_in">int</span> nums2Size)&#123;</span><br><span class="line">    <span class="built_in">int</span> n = nums1Size, m = nums2Size;</span><br><span class="line">    <span class="comment">//确保第一个数组最短。</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; m)&#123;</span><br><span class="line">        <span class="keyword">return</span> findMedianSortedArrays(nums2, m,  nums1, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> Lmax1,Lmax2,Rmin1,Rmin2,<span class="built_in">array</span>1,<span class="built_in">array</span>2,head = <span class="number">0</span>,tail = <span class="number">2</span> * n;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail)&#123;</span><br><span class="line">        <span class="built_in">array</span>1 = (head + tail) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">array</span>2 = n + m - <span class="built_in">array</span>1;</span><br><span class="line"></span><br><span class="line">        Lmax1 = (<span class="built_in">array</span>1 == <span class="number">0</span>) ? INT_MIN : nums1[(<span class="built_in">array</span>1 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">        Rmin1 = (<span class="built_in">array</span>1 == <span class="number">2</span> * n) ? INT_MAX : nums1[<span class="built_in">array</span>1 / <span class="number">2</span>];</span><br><span class="line">        Lmax2 = (<span class="built_in">array</span>2 == <span class="number">0</span>) ? INT_MIN : nums2[(<span class="built_in">array</span>2 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">        Rmin2 = (<span class="built_in">array</span>2 == <span class="number">2</span> * m) ? INT_MAX : nums2[<span class="built_in">array</span>2 / <span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (Lmax1 &gt; Rmin2)&#123;</span><br><span class="line">            tail = <span class="built_in">array</span>1 - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (Lmax2 &gt; Rmin1)&#123;</span><br><span class="line">            head = <span class="built_in">array</span>1 + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  ( max(Lmax1,Lmax2) + min(Rmin1,Rmin2) ) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O (log(m + n))</code>。</li><li>空间复杂度：<code>O (1)</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/2022/10/04/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/10/04/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><p>相比WYSIWYG编辑器</p><p><strong>优点：</strong></p><ol><li><p>因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。</p></li><li><p>操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可</p></li></ol><br/><p><strong>缺点：</strong></p><ol><li><p>需要记一些语法（当然，是很简单。五分钟学会）。</p></li><li><p>有些平台不支持Markdown编辑模式。</p></li></ol> <span id="more"></span><br/><p>还好，简书是支持Markdown编辑模式的。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开启方式：设置-&gt;默认编辑器-&gt;Markdown编辑器</span><br></pre></td></tr></table></figure><h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><p>在想要设置为标题的文字前面加#来表示</p><p>一个#是一级标题，二个#是二级标题，以此 <code>类推</code>。支持六级标题。</p><br/> <p>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。</p><br/><p>示例：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure><p>效果如下：</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><hr><h1 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h1><ul><li><strong>加粗</strong></li></ul><p>要加粗的文字左右分别用两个*号包起来</p><ul><li><strong>斜体</strong></li></ul><p>要倾斜的文字左右分别用一个*号包起来</p><ul><li><strong>斜体加粗</strong></li></ul><p>要倾斜和加粗的文字左右分别用三个*号包起来</p><ul><li><strong>删除线</strong></li></ul><p>要加删除线的文字左右分别用两个~~号包起来</p><br/><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**这是加粗的文字**</span></span><br><span class="line"><span class="emphasis">*这是倾斜的文字*</span>`</span><br><span class="line"><span class="strong">**<span class="emphasis">*这是斜体加粗的文字*</span>**</span></span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><strong>这是加粗的文字</strong></p><p><em>这是倾斜的文字</em>&#96;</p><p><em><strong>这是斜体加粗的文字</strong></em></p><p><del>这是加删除线的文字</del></p><h1 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h1><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;</p><p>n个…</p><p>貌似可以一直加下去，但没神马卵用</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">这是引用的内容</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;这是引用的内容</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h1 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h1><p>三个或者三个以上的 - 或者 * 都可以。</p><p>示例：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">---</span></span><br><span class="line"><span class="section">----</span></span><br><span class="line"><span class="bullet">***</span></span><br><span class="line"><span class="bullet"></span><span class="strong">*****</span></span><br></pre></td></tr></table></figure><h2 id="效果如下："><a href="#效果如下：" class="headerlink" title="效果如下："></a>效果如下：</h2><hr><hr><hr><p>可以看到，显示效果是一样的。</p><h1 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h1><p><strong>语法：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 <span class="string">&#x27;&#x27;</span>图片titl<span class="string">e&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="selector-attr">[blockchain]</span>(./../img/<span class="number">6860761</span>-fd2f51090a890873<span class="selector-class">.webp</span> <span class="string">&quot;区块链&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><p><img src="/./../img/6860761-fd2f51090a890873.webp" alt="blockchain" title="区块链"></p><p><strong>上传本地图片直接点击导航栏的图片标志，选择图片即可</strong></p><br/><h1 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h1><p><strong>语法：</strong></p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接<span class="built_in">title</span>&quot;)</span><br><span class="line"><span class="built_in">title</span>可加可不加</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[简书]</span>(<span class="attribute">http</span>:<span class="comment">//jianshu.com)</span></span><br><span class="line">[百度](<span class="attribute">http</span>:<span class="comment">//baidu.com)</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="http://jianshu.com/">简书</a><br><a href="http://baidu.com/">百度</a></p><p>注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a <span class="attribute">href</span>=<span class="string">&quot;超链接地址&quot;</span> <span class="attribute">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;超链接名&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">&lt;a <span class="attribute">href</span>=<span class="string">&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot;</span> <span class="attribute">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;简书&lt;/a&gt;</span><br></pre></td></tr></table></figure><h1 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h1><p><strong>无序列表</strong></p><p>语法：</p><p>无序列表用 - + * 任何一种都可以</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 列表内容</span><br><span class="line"><span class="bullet">+</span> 列表内容</span><br><span class="line"><span class="bullet">*</span> 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + <span class="emphasis">* 跟内容之间都要有一个空格</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><p><strong>有序列表</strong></p><p>语法：</p><p>数字加点</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 列表内容</span><br><span class="line"><span class="bullet">2.</span> 列表内容</span><br><span class="line"><span class="bullet">3.</span> 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure><p>效果如下：</p><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><p><strong>列表嵌套</strong></p><p><strong>上一级和下一级之间敲三个空格即可</strong></p><ul><li><p>一级无序列表内容</p><ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li><p>一级无序列表内容</p><ol><li>二级有序列表内容</li><li>二级有序列表内容</li><li>二级有序列表内容</li></ol></li></ul><ol><li><p>一级有序列表内容</p><ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li><p>一级有序列表内容</p><ul><li>二级有序列表内容</li><li>二级有序列表内容</li><li>二级有序列表内容</li></ul></li></ol><br/><hr><h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><p>语法：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|<span class="string">表头</span>|<span class="string">表头</span></span><br><span class="line"><span class="string">---</span>|<span class="string">:--:</span>|<span class="string">---:</span></span><br><span class="line"><span class="string">内容</span>|<span class="string">内容</span>|<span class="string">内容</span></span><br><span class="line"><span class="string">内容</span>|<span class="string">内容</span>|<span class="string">内容</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">第二行分割表头和内容。</span></span><br><span class="line"><span class="string">- 有一个就行，为了对齐，多加了几个</span></span><br><span class="line"><span class="string">文字默认居左</span></span><br><span class="line"><span class="string">-两边加：表示文字居中</span></span><br><span class="line"><span class="string">-右边加：表示文字居右</span></span><br><span class="line"><span class="string">注：原生的语法两边都要用 </span>|<span class="string"> 包起来。此处省略</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名|<span class="string">技能</span>|<span class="string">排行</span></span><br><span class="line"><span class="string">--</span>|<span class="string">:--:</span>|<span class="string">--:</span></span><br><span class="line"><span class="string">刘备</span>|<span class="string">哭</span>|<span class="string">大哥</span></span><br><span class="line"><span class="string">关羽</span>|<span class="string">打</span>|<span class="string">二哥</span></span><br><span class="line"><span class="string">张飞</span>|<span class="string">骂</span>|<span class="string">三弟</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><br/><h1 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h1><p>语法：</p><p>单行代码：代码之间分别用一个反引号包起来</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`代码内容`</span></span><br></pre></td></tr></table></figure><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><blockquote><p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中<br>去掉两边小括号即可。</p></blockquote><p>示例：</p><p>单行代码</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">create</span> <span class="keyword">database</span> hero;`</span><br></pre></td></tr></table></figure><p>代码块</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line">    function <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">         echo <span class="string">&quot;这是一句非常牛逼的代码&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>单行代码</p><p><code>create database hero;</code></p><p>代码块</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">  echo <span class="string">&quot;这是一句非常牛逼的代码&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h1 id="十、数字处理："><a href="#十、数字处理：" class="headerlink" title="十、数字处理："></a>十、数字处理：</h1><p><strong>上标和下标：</strong></p><ol><li>Markdown语法</li></ol><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>上标｜$x^2$: x^2^</td><td></td></tr><tr><td>下标｜$x_2$: x<del>2</del></td><td></td></tr></tbody></table><ol start="2"><li>使用LaTex</li></ol><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>上标｜$x^2$ : <code>$x^2$</code></td><td></td><td></td></tr><tr><td>下标｜$x_2$ : <code>$x_2x$</code></td><td></td><td></td></tr></tbody></table><ol start="3"><li>html 语法：</li></ol><p><strong>代码：</strong></p><p><code>C&lt;sub&gt;n-1&lt;/sub&gt;&lt;sup style=&quot;margin-left:-20px&quot;&gt;m+n-2&lt;/sup&gt;</code>  </p><p><strong>效果：</strong></p><p>C<sub>n-1</sub><sup style="margin-left:-20px">m+n-2</sup></p><p>单个<code>$</code>之间则可以嵌入文本当中，套两层$可实现公式居中。<br>如果要复合标，可使用 <code>&#123;&#125;</code>，如 $x^{C_2}$ : <code>$x^&#123;C_2&#125;$</code> </p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
